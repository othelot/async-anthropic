#![allow(dead_code)]
#![allow(deprecated)]

//!
//! AUTO-GENERATED CODE - DO NOT EDIT!
//!
//! Anthropic API
//! Source: stats.json
//! Version: 195
//! Generated by `oas3-gen v0.24.0`
//!
//! No description provided

use serde::{Deserialize, Serialize};
use validator::Validate;
static REGEX_BETA_MESSAGE_BATCH_INDIVIDUAL_REQUEST_PARAMS_CUSTOM_ID: std::sync::LazyLock<
    regex::Regex,
> = std::sync::LazyLock::new(|| regex::Regex::new("^[a-zA-Z0-9_-]{1,64}$").expect("invalid regex"));
static REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID: std::sync::LazyLock<
    regex::Regex,
> = std::sync::LazyLock::new(|| {
    regex::Regex::new("^srvtoolu_[a-zA-Z0-9_]+$").expect("invalid regex")
});
static REGEX_BETA_REQUEST_MCPTOOL_RESULT_BLOCK_TOOL_USE_ID: std::sync::LazyLock<regex::Regex> =
    std::sync::LazyLock::new(|| regex::Regex::new("^[a-zA-Z0-9_-]+$").expect("invalid regex"));
static REGEX_BETA_TOOL_NAME: std::sync::LazyLock<regex::Regex> = std::sync::LazyLock::new(|| {
    regex::Regex::new("^[a-zA-Z0-9_-]{1,128}$").expect("invalid regex")
});
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct APIError {
    #[validate(length(min = 1u64))]
    #[default(Some("Internal server error".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("api_error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum AnthropicBeta {
    #[default]
    Known(AnthropicBetaKnown),
    Other(String),
}
impl AnthropicBeta {
    pub fn message_batches20240924() -> Self {
        Self::Known(AnthropicBetaKnown::MessageBatches20240924)
    }
    pub fn prompt_caching20240731() -> Self {
        Self::Known(AnthropicBetaKnown::PromptCaching20240731)
    }
    pub fn computer_use20241022() -> Self {
        Self::Known(AnthropicBetaKnown::ComputerUse20241022)
    }
    pub fn computer_use20250124() -> Self {
        Self::Known(AnthropicBetaKnown::ComputerUse20250124)
    }
    pub fn pdfs20240925() -> Self {
        Self::Known(AnthropicBetaKnown::Pdfs20240925)
    }
    pub fn token_counting20241101() -> Self {
        Self::Known(AnthropicBetaKnown::TokenCounting20241101)
    }
    pub fn token_efficient_tools20250219() -> Self {
        Self::Known(AnthropicBetaKnown::TokenEfficientTools20250219)
    }
    pub fn output128k20250219() -> Self {
        Self::Known(AnthropicBetaKnown::Output128k20250219)
    }
    pub fn files_api20250414() -> Self {
        Self::Known(AnthropicBetaKnown::FilesApi20250414)
    }
    pub fn mcp_client20250404() -> Self {
        Self::Known(AnthropicBetaKnown::McpClient20250404)
    }
    pub fn mcp_client20251120() -> Self {
        Self::Known(AnthropicBetaKnown::McpClient20251120)
    }
    pub fn dev_full_thinking20250514() -> Self {
        Self::Known(AnthropicBetaKnown::DevFullThinking20250514)
    }
    pub fn interleaved_thinking20250514() -> Self {
        Self::Known(AnthropicBetaKnown::InterleavedThinking20250514)
    }
    pub fn code_execution20250522() -> Self {
        Self::Known(AnthropicBetaKnown::CodeExecution20250522)
    }
    pub fn extended_cache_ttl20250411() -> Self {
        Self::Known(AnthropicBetaKnown::ExtendedCacheTtl20250411)
    }
    pub fn context1m20250807() -> Self {
        Self::Known(AnthropicBetaKnown::Context1m20250807)
    }
    pub fn context_management20250627() -> Self {
        Self::Known(AnthropicBetaKnown::ContextManagement20250627)
    }
    pub fn model_context_window_exceeded20250826() -> Self {
        Self::Known(AnthropicBetaKnown::ModelContextWindowExceeded20250826)
    }
    pub fn skills20251002() -> Self {
        Self::Known(AnthropicBetaKnown::Skills20251002)
    }
}
impl core::fmt::Display for AnthropicBeta {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Known(v) => write!(f, "{v}"),
            Self::Other(v) => write!(f, "{v}"),
        }
    }
}
///Known values for the string enum.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum AnthropicBetaKnown {
    #[serde(rename = "message-batches-2024-09-24")]
    #[default]
    MessageBatches20240924,
    #[serde(rename = "prompt-caching-2024-07-31")]
    PromptCaching20240731,
    #[serde(rename = "computer-use-2024-10-22")]
    ComputerUse20241022,
    #[serde(rename = "computer-use-2025-01-24")]
    ComputerUse20250124,
    #[serde(rename = "pdfs-2024-09-25")]
    Pdfs20240925,
    #[serde(rename = "token-counting-2024-11-01")]
    TokenCounting20241101,
    #[serde(rename = "token-efficient-tools-2025-02-19")]
    TokenEfficientTools20250219,
    #[serde(rename = "output-128k-2025-02-19")]
    Output128k20250219,
    #[serde(rename = "files-api-2025-04-14")]
    FilesApi20250414,
    #[serde(rename = "mcp-client-2025-04-04")]
    McpClient20250404,
    #[serde(rename = "mcp-client-2025-11-20")]
    McpClient20251120,
    #[serde(rename = "dev-full-thinking-2025-05-14")]
    DevFullThinking20250514,
    #[serde(rename = "interleaved-thinking-2025-05-14")]
    InterleavedThinking20250514,
    #[serde(rename = "code-execution-2025-05-22")]
    CodeExecution20250522,
    #[serde(rename = "extended-cache-ttl-2025-04-11")]
    ExtendedCacheTtl20250411,
    #[serde(rename = "context-1m-2025-08-07")]
    Context1m20250807,
    #[serde(rename = "context-management-2025-06-27")]
    ContextManagement20250627,
    #[serde(rename = "model-context-window-exceeded-2025-08-26")]
    ModelContextWindowExceeded20250826,
    #[serde(rename = "skills-2025-10-02")]
    Skills20251002,
}
impl core::fmt::Display for AnthropicBetaKnown {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::MessageBatches20240924 => write!(f, "message-batches-2024-09-24"),
            Self::PromptCaching20240731 => write!(f, "prompt-caching-2024-07-31"),
            Self::ComputerUse20241022 => write!(f, "computer-use-2024-10-22"),
            Self::ComputerUse20250124 => write!(f, "computer-use-2025-01-24"),
            Self::Pdfs20240925 => write!(f, "pdfs-2024-09-25"),
            Self::TokenCounting20241101 => write!(f, "token-counting-2024-11-01"),
            Self::TokenEfficientTools20250219 => {
                write!(f, "token-efficient-tools-2025-02-19")
            }
            Self::Output128k20250219 => write!(f, "output-128k-2025-02-19"),
            Self::FilesApi20250414 => write!(f, "files-api-2025-04-14"),
            Self::McpClient20250404 => write!(f, "mcp-client-2025-04-04"),
            Self::McpClient20251120 => write!(f, "mcp-client-2025-11-20"),
            Self::DevFullThinking20250514 => write!(f, "dev-full-thinking-2025-05-14"),
            Self::InterleavedThinking20250514 => {
                write!(f, "interleaved-thinking-2025-05-14")
            }
            Self::CodeExecution20250522 => write!(f, "code-execution-2025-05-22"),
            Self::ExtendedCacheTtl20250411 => write!(f, "extended-cache-ttl-2025-04-11"),
            Self::Context1m20250807 => write!(f, "context-1m-2025-08-07"),
            Self::ContextManagement20250627 => write!(f, "context-management-2025-06-27"),
            Self::ModelContextWindowExceeded20250826 => {
                write!(f, "model-context-window-exceeded-2025-08-26")
            }
            Self::Skills20251002 => write!(f, "skills-2025-10-02"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct AuthenticationError {
    #[validate(length(min = 1u64))]
    #[default(Some("Authentication error".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("authentication_error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct Base64ImageSource {
    pub data: Vec<u8>,
    pub media_type: Base64ImageSourceMediaType,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("base64".to_string())]
    pub r#type: String,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum Base64ImageSourceMediaType {
    #[serde(rename = "image/jpeg")]
    #[default]
    ImageJpeg,
    #[serde(rename = "image/png")]
    ImagePng,
    #[serde(rename = "image/gif")]
    ImageGif,
    #[serde(rename = "image/webp")]
    ImageWebp,
}
impl core::fmt::Display for Base64ImageSourceMediaType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ImageJpeg => write!(f, "image/jpeg"),
            Self::ImagePng => write!(f, "image/png"),
            Self::ImageGif => write!(f, "image/gif"),
            Self::ImageWebp => write!(f, "image/webp"),
        }
    }
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct Base64PDFSource {
    pub data: Vec<u8>,
    #[validate(length(min = 1u64))]
    #[default("application/pdf".to_string())]
    pub media_type: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("base64".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BashTool20250124 {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("bash".to_string())]
    pub name: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("bash_20250124".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaAPIError {
    #[validate(length(min = 1u64))]
    #[default(Some("Internal server error".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("api_error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaAllThinkingTurns {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("all".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaAuthenticationError {
    #[validate(length(min = 1u64))]
    #[default(Some("Authentication error".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("authentication_error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaBase64ImageSource {
    pub data: Vec<u8>,
    pub media_type: Base64ImageSourceMediaType,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("base64".to_string())]
    pub r#type: String,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaBase64PDFSource {
    pub data: Vec<u8>,
    #[validate(length(min = 1u64))]
    #[default("application/pdf".to_string())]
    pub media_type: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("base64".to_string())]
    pub r#type: String,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaBashCodeExecutionToolResultErrorCode {
    #[serde(rename = "invalid_tool_input")]
    #[default]
    InvalidToolInput,
    #[serde(rename = "unavailable")]
    Unavailable,
    #[serde(rename = "too_many_requests")]
    TooManyRequests,
    #[serde(rename = "execution_time_exceeded")]
    ExecutionTimeExceeded,
    #[serde(rename = "output_file_too_large")]
    OutputFileTooLarge,
}
impl core::fmt::Display for BetaBashCodeExecutionToolResultErrorCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::InvalidToolInput => write!(f, "invalid_tool_input"),
            Self::Unavailable => write!(f, "unavailable"),
            Self::TooManyRequests => write!(f, "too_many_requests"),
            Self::ExecutionTimeExceeded => write!(f, "execution_time_exceeded"),
            Self::OutputFileTooLarge => write!(f, "output_file_too_large"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaBashTool20241022 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    pub input_examples: Option<Vec<std::collections::HashMap<String, BetaJsonValue>>>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("bash".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("bash_20241022".to_string())]
    pub r#type: String,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaBashTool20241022AllowedCaller {
    #[serde(rename = "direct")]
    #[default]
    Direct,
    #[serde(rename = "code_execution_20250825")]
    CodeExecution20250825,
}
impl core::fmt::Display for BetaBashTool20241022AllowedCaller {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Direct => write!(f, "direct"),
            Self::CodeExecution20250825 => write!(f, "code_execution_20250825"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaBashTool20250124 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    pub input_examples: Option<Vec<std::collections::HashMap<String, BetaJsonValue>>>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("bash".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("bash_20250124".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaBillingError {
    #[validate(length(min = 1u64))]
    #[default(Some("Billing error".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("billing_error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaBlockKind {
    Image(BetaRequestImageBlock),
    Text(BetaRequestTextBlock),
}
impl BetaBlockKind {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaBlockKind {
    fn default() -> Self {
        Self::Image(<BetaRequestImageBlock>::default())
    }
}
impl serde::Serialize for BetaBlockKind {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Image(v) => v.serialize(serializer),
            Self::Text(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaBlockKind {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("image") => serde_json::from_value(value)
                .map(Self::Image)
                .map_err(serde::de::Error::custom),
            Some("text") => serde_json::from_value(value)
                .map(Self::Text)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaBlockKind {
    pub fn text(text: String) -> Self {
        Self::Text(BetaRequestTextBlock {
            text,
            ..Default::default()
        })
    }
    pub fn image(source: BetaRequestImageBlockSource) -> Self {
        Self::Image(BetaRequestImageBlock {
            source,
            ..Default::default()
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaBlockKind2 {
    Document(BetaRequestDocumentBlock),
    Image(BetaRequestImageBlock),
    SearchResult(BetaRequestSearchResultBlock),
    Text(BetaRequestTextBlock),
    ToolReference(BetaRequestToolReferenceBlock),
}
impl BetaBlockKind2 {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaBlockKind2 {
    fn default() -> Self {
        Self::Document(<BetaRequestDocumentBlock>::default())
    }
}
impl serde::Serialize for BetaBlockKind2 {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Document(v) => v.serialize(serializer),
            Self::Image(v) => v.serialize(serializer),
            Self::SearchResult(v) => v.serialize(serializer),
            Self::Text(v) => v.serialize(serializer),
            Self::ToolReference(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaBlockKind2 {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("document") => serde_json::from_value(value)
                .map(Self::Document)
                .map_err(serde::de::Error::custom),
            Some("image") => serde_json::from_value(value)
                .map(Self::Image)
                .map_err(serde::de::Error::custom),
            Some("search_result") => serde_json::from_value(value)
                .map(Self::SearchResult)
                .map_err(serde::de::Error::custom),
            Some("text") => serde_json::from_value(value)
                .map(Self::Text)
                .map_err(serde::de::Error::custom),
            Some("tool_reference") => serde_json::from_value(value)
                .map(Self::ToolReference)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaBlockKind2 {
    pub fn text(text: String) -> Self {
        Self::Text(BetaRequestTextBlock {
            text,
            ..Default::default()
        })
    }
    pub fn image(source: BetaRequestImageBlockSource) -> Self {
        Self::Image(BetaRequestImageBlock {
            source,
            ..Default::default()
        })
    }
    pub fn document(source: BetaRequestDocumentBlockSource) -> Self {
        Self::Document(BetaRequestDocumentBlock {
            source,
            ..Default::default()
        })
    }
    ///Tool reference block that can be included in tool_result content.
    pub fn tool_reference(tool_name: String) -> Self {
        Self::ToolReference(BetaRequestToolReferenceBlock {
            tool_name,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub struct BetaBodyCreateSkillV1SkillsPost {
    ///Display title for the skill.
    ///
    ///This is a human-readable label that is not included in the prompt sent to the model.
    pub display_title: Option<String>,
    ///Files to upload for the skill.
    ///
    ///All files must be in the same top-level directory and must include a SKILL.md file at the root of that directory.
    pub files: Option<Vec<Vec<u8>>>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub struct BetaBodyCreateSkillVersionV1SkillsSkillIdVersionsPost {
    ///Files to upload for the skill.
    ///
    ///All files must be in the same top-level directory and must include a SKILL.md file at the root of that directory.
    pub files: Option<Vec<Vec<u8>>>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaCacheControlEphemeral {
    ///The time-to-live for the cache control breakpoint.
    ///
    ///This may be one the following values:
    ///- `5m`: 5 minutes
    ///- `1h`: 1 hour
    ///
    ///Defaults to `5m`.
    pub ttl: Option<CacheControlEphemeralTtl>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("ephemeral".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaCacheCreation {
    ///The number of input tokens used to create the 1 hour cache entry.
    #[validate(range(min = 0i64))]
    #[default(Some(0i64))]
    pub ephemeral_1h_input_tokens: Option<i64>,
    ///The number of input tokens used to create the 5 minute cache entry.
    #[validate(range(min = 0i64))]
    #[default(Some(0i64))]
    pub ephemeral_5m_input_tokens: Option<i64>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaCanceledResult {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("canceled".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaCitationsDelta {
    pub citation: BetaCitationsDeltaCitation,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("citations_delta".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaCitationsDeltaCitation {
    Char(BetaResponseCharLocationCitation),
    ContentBlock(BetaResponseContentBlockLocationCitation),
    Page(BetaResponsePageLocationCitation),
    SearchResult(BetaResponseSearchResultLocationCitation),
    WebSearchResult(BetaResponseWebSearchResultLocationCitation),
}
impl BetaCitationsDeltaCitation {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaCitationsDeltaCitation {
    fn default() -> Self {
        Self::Char(<BetaResponseCharLocationCitation>::default())
    }
}
impl serde::Serialize for BetaCitationsDeltaCitation {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Char(v) => v.serialize(serializer),
            Self::ContentBlock(v) => v.serialize(serializer),
            Self::Page(v) => v.serialize(serializer),
            Self::SearchResult(v) => v.serialize(serializer),
            Self::WebSearchResult(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaCitationsDeltaCitation {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("char_location") => serde_json::from_value(value)
                .map(Self::Char)
                .map_err(serde::de::Error::custom),
            Some("content_block_location") => serde_json::from_value(value)
                .map(Self::ContentBlock)
                .map_err(serde::de::Error::custom),
            Some("page_location") => serde_json::from_value(value)
                .map(Self::Page)
                .map_err(serde::de::Error::custom),
            Some("search_result_location") => serde_json::from_value(value)
                .map(Self::SearchResult)
                .map_err(serde::de::Error::custom),
            Some("web_search_result_location") => serde_json::from_value(value)
                .map(Self::WebSearchResult)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaClearEditKind {
    Thinking20251015(BetaClearThinking20251015),
    ToolUses20250919(BetaClearToolUses20250919),
}
impl BetaClearEditKind {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaClearEditKind {
    fn default() -> Self {
        Self::Thinking20251015(<BetaClearThinking20251015>::default())
    }
}
impl serde::Serialize for BetaClearEditKind {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Thinking20251015(v) => v.serialize(serializer),
            Self::ToolUses20250919(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaClearEditKind {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("clear_thinking_20251015") => serde_json::from_value(value)
                .map(Self::Thinking20251015)
                .map_err(serde::de::Error::custom),
            Some("clear_tool_uses_20250919") => serde_json::from_value(value)
                .map(Self::ToolUses20250919)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaClearEditKind {
    pub fn tool_uses20250919() -> Self {
        Self::ToolUses20250919(BetaClearToolUses20250919::default())
    }
    pub fn thinking20251015() -> Self {
        Self::Thinking20251015(BetaClearThinking20251015::default())
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaClearThinking20251015 {
    ///Number of most recent assistant turns to keep thinking blocks for. Older turns will have their thinking blocks removed.
    pub keep: Option<BetaClearThinking20251015Keep>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("clear_thinking_20251015".to_string())]
    pub r#type: String,
}
///Number of most recent assistant turns to keep thinking blocks for. Older turns will have their thinking blocks removed.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaClearThinking20251015Keep {
    #[default]
    BetaThinkingTurns(BetaThinkingTurnsKind),
    #[serde(rename = "all")]
    All,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaClearToolUses20250919 {
    ///Minimum number of tokens that must be cleared when triggered. Context will only be modified if at least this many tokens can be removed.
    #[validate(nested)]
    pub clear_at_least: Option<BetaInputTokensClearAtLeast>,
    ///Whether to clear all tool inputs (bool) or specific tool inputs to clear (list)
    pub clear_tool_inputs: Option<BetaClearToolUses20250919ClearToolInputs>,
    ///Tool names whose uses are preserved from clearing
    pub exclude_tools: Option<Vec<String>>,
    ///Number of tool uses to retain in the conversation
    pub keep: Option<BetaClearToolUses20250919Keep>,
    ///Condition that triggers the context management strategy
    pub trigger: Option<BetaClearToolUses20250919Trigger>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("clear_tool_uses_20250919".to_string())]
    pub r#type: String,
}
///Whether to clear all tool inputs (bool) or specific tool inputs to clear (list)
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaClearToolUses20250919ClearToolInputs {
    #[default]
    Boolean(bool),
    Array(Vec<String>),
}
///Number of tool uses to retain in the conversation
#[derive(Debug, Clone, PartialEq)]
pub enum BetaClearToolUses20250919Keep {
    BetaToolUsesKeep(BetaToolUsesKeep),
}
impl BetaClearToolUses20250919Keep {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaClearToolUses20250919Keep {
    fn default() -> Self {
        Self::BetaToolUsesKeep(<BetaToolUsesKeep>::default())
    }
}
impl serde::Serialize for BetaClearToolUses20250919Keep {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::BetaToolUsesKeep(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaClearToolUses20250919Keep {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("tool_uses") => serde_json::from_value(value)
                .map(Self::BetaToolUsesKeep)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaClearToolUses20250919Keep {
    pub fn uses(value: i64) -> Self {
        Self::BetaToolUsesKeep(BetaToolUsesKeep {
            value,
            ..Default::default()
        })
    }
}
///Condition that triggers the context management strategy
#[derive(Debug, Clone, PartialEq)]
pub enum BetaClearToolUses20250919Trigger {
    InputTokens(BetaInputTokensTrigger),
    ToolUses(BetaToolUsesTrigger),
}
impl BetaClearToolUses20250919Trigger {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaClearToolUses20250919Trigger {
    fn default() -> Self {
        Self::InputTokens(<BetaInputTokensTrigger>::default())
    }
}
impl serde::Serialize for BetaClearToolUses20250919Trigger {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::InputTokens(v) => v.serialize(serializer),
            Self::ToolUses(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaClearToolUses20250919Trigger {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("input_tokens") => serde_json::from_value(value)
                .map(Self::InputTokens)
                .map_err(serde::de::Error::custom),
            Some("tool_uses") => serde_json::from_value(value)
                .map(Self::ToolUses)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaClearToolUses20250919Trigger {
    pub fn input_tokens(value: i64) -> Self {
        Self::InputTokens(BetaInputTokensTrigger {
            value,
            ..Default::default()
        })
    }
    pub fn uses(value: i64) -> Self {
        Self::ToolUses(BetaToolUsesTrigger {
            value,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaCodeExecutionTool20250522 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("code_execution".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("code_execution_20250522".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaCodeExecutionTool20250825 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("code_execution".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("code_execution_20250825".to_string())]
    pub r#type: String,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaCodeExecutionToolResultErrorCode {
    #[serde(rename = "invalid_tool_input")]
    #[default]
    InvalidToolInput,
    #[serde(rename = "unavailable")]
    Unavailable,
    #[serde(rename = "too_many_requests")]
    TooManyRequests,
    #[serde(rename = "execution_time_exceeded")]
    ExecutionTimeExceeded,
}
impl core::fmt::Display for BetaCodeExecutionToolResultErrorCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::InvalidToolInput => write!(f, "invalid_tool_input"),
            Self::Unavailable => write!(f, "unavailable"),
            Self::TooManyRequests => write!(f, "too_many_requests"),
            Self::ExecutionTimeExceeded => write!(f, "execution_time_exceeded"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaComputerUseTool20241022 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    ///The height of the display in pixels.
    #[validate(range(min = 1i64))]
    pub display_height_px: i64,
    ///The X11 display number (e.g. 0, 1) for the display.
    pub display_number: Option<i64>,
    ///The width of the display in pixels.
    #[validate(range(min = 1i64))]
    pub display_width_px: i64,
    pub input_examples: Option<Vec<std::collections::HashMap<String, BetaJsonValue>>>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("computer".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("computer_20241022".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaComputerUseTool20250124 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    ///The height of the display in pixels.
    #[validate(range(min = 1i64))]
    pub display_height_px: i64,
    ///The X11 display number (e.g. 0, 1) for the display.
    pub display_number: Option<i64>,
    ///The width of the display in pixels.
    #[validate(range(min = 1i64))]
    pub display_width_px: i64,
    pub input_examples: Option<Vec<std::collections::HashMap<String, BetaJsonValue>>>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("computer".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("computer_20250124".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaComputerUseTool20251124 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    ///The height of the display in pixels.
    #[validate(range(min = 1i64))]
    pub display_height_px: i64,
    ///The X11 display number (e.g. 0, 1) for the display.
    pub display_number: Option<i64>,
    ///The width of the display in pixels.
    #[validate(range(min = 1i64))]
    pub display_width_px: i64,
    ///Whether to enable an action to take a zoomed-in screenshot of the screen.
    pub enable_zoom: Option<bool>,
    pub input_examples: Option<Vec<std::collections::HashMap<String, BetaJsonValue>>>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("computer".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("computer_20251124".to_string())]
    pub r#type: String,
}
///Information about the container used in the request (for the code execution tool)
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct BetaContainer {
    ///The time at which the container will expire.
    pub expires_at: chrono::DateTime<chrono::Utc>,
    ///Identifier for the container used in this request
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Skills loaded in the container
    #[validate(nested)]
    pub skills: Option<Vec<BetaSkill>>,
}
///Container parameters with skills to be loaded.
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct BetaContainerParams {
    ///Container id
    pub id: Option<String>,
    ///List of skills to load in the container
    #[validate(nested)]
    pub skills: Option<Vec<BetaSkillParams>>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaContentBlock {
    BashCodeExecutionToolResult(BetaResponseBashCodeExecutionToolResultBlock),
    CodeExecutionToolResult(BetaResponseCodeExecutionToolResultBlock),
    ContainerUpload(BetaResponseContainerUploadBlock),
    MCPToolResult(BetaResponseMCPToolResultBlock),
    MCPToolUse(BetaResponseMCPToolUseBlock),
    RedactedThinking(BetaResponseRedactedThinkingBlock),
    ServerToolUse(BetaResponseServerToolUseBlock),
    Text(BetaResponseTextBlock),
    TextEditorCodeExecutionToolResult(BetaResponseTextEditorCodeExecutionToolResultBlock),
    Thinking(BetaResponseThinkingBlock),
    ToolSearchToolResult(BetaResponseToolSearchToolResultBlock),
    ToolUse(BetaResponseToolUseBlock),
    WebFetchToolResult(BetaResponseWebFetchToolResultBlock),
    WebSearchToolResult(BetaResponseWebSearchToolResultBlock),
}
impl BetaContentBlock {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaContentBlock {
    fn default() -> Self {
        Self::BashCodeExecutionToolResult(<BetaResponseBashCodeExecutionToolResultBlock>::default())
    }
}
impl serde::Serialize for BetaContentBlock {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::BashCodeExecutionToolResult(v) => v.serialize(serializer),
            Self::CodeExecutionToolResult(v) => v.serialize(serializer),
            Self::ContainerUpload(v) => v.serialize(serializer),
            Self::MCPToolResult(v) => v.serialize(serializer),
            Self::MCPToolUse(v) => v.serialize(serializer),
            Self::RedactedThinking(v) => v.serialize(serializer),
            Self::ServerToolUse(v) => v.serialize(serializer),
            Self::Text(v) => v.serialize(serializer),
            Self::TextEditorCodeExecutionToolResult(v) => v.serialize(serializer),
            Self::Thinking(v) => v.serialize(serializer),
            Self::ToolSearchToolResult(v) => v.serialize(serializer),
            Self::ToolUse(v) => v.serialize(serializer),
            Self::WebFetchToolResult(v) => v.serialize(serializer),
            Self::WebSearchToolResult(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaContentBlock {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("bash_code_execution_tool_result") => serde_json::from_value(value)
                .map(Self::BashCodeExecutionToolResult)
                .map_err(serde::de::Error::custom),
            Some("code_execution_tool_result") => serde_json::from_value(value)
                .map(Self::CodeExecutionToolResult)
                .map_err(serde::de::Error::custom),
            Some("container_upload") => serde_json::from_value(value)
                .map(Self::ContainerUpload)
                .map_err(serde::de::Error::custom),
            Some("mcp_tool_result") => serde_json::from_value(value)
                .map(Self::MCPToolResult)
                .map_err(serde::de::Error::custom),
            Some("mcp_tool_use") => serde_json::from_value(value)
                .map(Self::MCPToolUse)
                .map_err(serde::de::Error::custom),
            Some("redacted_thinking") => serde_json::from_value(value)
                .map(Self::RedactedThinking)
                .map_err(serde::de::Error::custom),
            Some("server_tool_use") => serde_json::from_value(value)
                .map(Self::ServerToolUse)
                .map_err(serde::de::Error::custom),
            Some("text") => serde_json::from_value(value)
                .map(Self::Text)
                .map_err(serde::de::Error::custom),
            Some("text_editor_code_execution_tool_result") => serde_json::from_value(value)
                .map(Self::TextEditorCodeExecutionToolResult)
                .map_err(serde::de::Error::custom),
            Some("thinking") => serde_json::from_value(value)
                .map(Self::Thinking)
                .map_err(serde::de::Error::custom),
            Some("tool_search_tool_result") => serde_json::from_value(value)
                .map(Self::ToolSearchToolResult)
                .map_err(serde::de::Error::custom),
            Some("tool_use") => serde_json::from_value(value)
                .map(Self::ToolUse)
                .map_err(serde::de::Error::custom),
            Some("web_fetch_tool_result") => serde_json::from_value(value)
                .map(Self::WebFetchToolResult)
                .map_err(serde::de::Error::custom),
            Some("web_search_tool_result") => serde_json::from_value(value)
                .map(Self::WebSearchToolResult)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaContentBlock {
    pub fn redacted_thinking(data: String) -> Self {
        Self::RedactedThinking(BetaResponseRedactedThinkingBlock {
            data,
            ..Default::default()
        })
    }
    ///Response model for a file uploaded to the container.
    pub fn container_upload(file_id: String) -> Self {
        Self::ContainerUpload(BetaResponseContainerUploadBlock {
            file_id,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct BetaContentBlockDeltaEvent {
    pub delta: BetaContentBlockDeltaEventDelta,
    pub index: i64,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("content_block_delta".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaContentBlockDeltaEventDelta {
    Citations(BetaCitationsDelta),
    InputJsonContentBlock(BetaInputJsonContentBlockDelta),
    SignatureContentBlock(BetaSignatureContentBlockDelta),
    TextContentBlock(BetaTextContentBlockDelta),
    ThinkingContentBlock(BetaThinkingContentBlockDelta),
}
impl BetaContentBlockDeltaEventDelta {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaContentBlockDeltaEventDelta {
    fn default() -> Self {
        Self::Citations(<BetaCitationsDelta>::default())
    }
}
impl serde::Serialize for BetaContentBlockDeltaEventDelta {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Citations(v) => v.serialize(serializer),
            Self::InputJsonContentBlock(v) => v.serialize(serializer),
            Self::SignatureContentBlock(v) => v.serialize(serializer),
            Self::TextContentBlock(v) => v.serialize(serializer),
            Self::ThinkingContentBlock(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaContentBlockDeltaEventDelta {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("citations_delta") => serde_json::from_value(value)
                .map(Self::Citations)
                .map_err(serde::de::Error::custom),
            Some("input_json_delta") => serde_json::from_value(value)
                .map(Self::InputJsonContentBlock)
                .map_err(serde::de::Error::custom),
            Some("signature_delta") => serde_json::from_value(value)
                .map(Self::SignatureContentBlock)
                .map_err(serde::de::Error::custom),
            Some("text_delta") => serde_json::from_value(value)
                .map(Self::TextContentBlock)
                .map_err(serde::de::Error::custom),
            Some("thinking_delta") => serde_json::from_value(value)
                .map(Self::ThinkingContentBlock)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaContentBlockDeltaEventDelta {
    pub fn text(text: String) -> Self {
        Self::TextContentBlock(BetaTextContentBlockDelta {
            text,
            ..Default::default()
        })
    }
    pub fn input_json(partial_json: String) -> Self {
        Self::InputJsonContentBlock(BetaInputJsonContentBlockDelta {
            partial_json,
            ..Default::default()
        })
    }
    pub fn citations(citation: BetaCitationsDeltaCitation) -> Self {
        Self::Citations(BetaCitationsDelta {
            citation,
            ..Default::default()
        })
    }
    pub fn thinking(thinking: String) -> Self {
        Self::ThinkingContentBlock(BetaThinkingContentBlockDelta {
            thinking,
            ..Default::default()
        })
    }
    pub fn signature(signature: String) -> Self {
        Self::SignatureContentBlock(BetaSignatureContentBlockDelta {
            signature,
            ..Default::default()
        })
    }
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaContentBlockSource {
    pub content: BetaContentBlockSourceContent,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("content".to_string())]
    pub r#type: String,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaContentBlockSourceContent {
    #[default]
    String(String),
    BetaContentBlockSourceContent(Vec<BetaBlockKind>),
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct BetaContentBlockStartEvent {
    pub content_block: Box<BetaContentBlock>,
    pub index: i64,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("content_block_start".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct BetaContentBlockStopEvent {
    pub index: i64,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("content_block_stop".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct BetaContextManagementConfig {
    ///List of context management edits to apply
    #[validate(length(min = 0u64))]
    pub edits: Option<Vec<BetaClearEditKind>>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub struct BetaContextManagementResponse {
    ///The original token count before context management was applied
    pub original_input_tokens: i64,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct BetaCountMessageTokensParams {
    ///Context management configuration.
    ///
    ///This allows you to control how Claude manages context across multiple requests, such as whether to clear function results or not.
    #[validate(nested)]
    pub context_management: Option<BetaContextManagementConfig>,
    ///MCP servers to be utilized in this request
    #[validate(length(max = 20u64), nested)]
    pub mcp_servers: Option<Vec<BetaRequestMCPServerURLDefinition>>,
    ///Input messages.
    ///
    ///Our models are trained to operate on alternating `user` and `assistant` conversational turns. When creating a new `Message`, you specify the prior conversational turns with the `messages` parameter, and the model then generates the next `Message` in the conversation. Consecutive `user` or `assistant` turns in your request will be combined into a single turn.
    ///
    ///Each input message must be an object with a `role` and `content`. You can specify a single `user`-role message, or you can include multiple `user` and `assistant` messages.
    ///
    ///If the final message uses the `assistant` role, the response content will continue immediately from the content in that message. This can be used to constrain part of the model's response.
    ///
    ///Example with a single `user` message:
    ///
    ///```json
    ///[{"role": "user", "content": "Hello, Claude"}]
    ///```
    ///
    ///Example with multiple conversational turns:
    ///
    ///```json
    ///[
    ///  {"role": "user", "content": "Hello there."},
    ///  {"role": "assistant", "content": "Hi, I'm Claude. How can I help you?"},
    ///  {"role": "user", "content": "Can you explain LLMs in plain English?"},
    ///]
    ///```
    ///
    ///Example with a partially-filled response from Claude:
    ///
    ///```json
    ///[
    ///  {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
    ///  {"role": "assistant", "content": "The best answer is ("},
    ///]
    ///```
    ///
    ///Each input message `content` may be either a single `string` or an array of content blocks, where each block has a specific `type`. Using a `string` for `content` is shorthand for an array of one content block of type `"text"`. The following input messages are equivalent:
    ///
    ///```json
    ///{"role": "user", "content": "Hello, Claude"}
    ///```
    ///
    ///```json
    ///{"role": "user", "content": [{"type": "text", "text": "Hello, Claude"}]}
    ///```
    ///
    ///See [input examples](https://docs.claude.com/en/api/messages-examples).
    ///
    ///Note that if you want to include a [system prompt](https://docs.claude.com/en/docs/system-prompts), you can use the top-level `system` parameter  there is no `"system"` role for input messages in the Messages API.
    ///
    ///There is a limit of 100,000 messages in a single request.
    pub messages: Vec<BetaInputMessage>,
    ///The model that will complete your prompt.
    ///
    ///See [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
    pub model: Model,
    pub output_config: Option<BetaOutputConfig>,
    ///
    ///A schema to specify Claude's output format in responses.
    #[validate(nested)]
    pub output_format: Option<BetaJsonOutputFormat>,
    ///System prompt.
    ///
    ///A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.claude.com/en/docs/system-prompts).
    pub system: Option<BetaCountMessageTokensParamsSystem>,
    ///Configuration for enabling Claude's extended thinking.
    ///
    ///When enabled, responses include `thinking` content blocks showing Claude's thinking process before the final answer. Requires a minimum budget of 1,024 tokens and counts towards your `max_tokens` limit.
    ///
    ///See [extended thinking](https://docs.claude.com/en/docs/build-with-claude/extended-thinking) for details.
    pub thinking: Option<Box<BetaThinkingConfigParam>>,
    ///How the model should use the provided tools. The model can use a specific tool, any available tool, decide by itself, or not use tools at all.
    pub tool_choice: Option<Box<BetaToolChoice>>,
    ///Definitions of tools that the model may use.
    ///
    ///If you include `tools` in your API request, the model may return `tool_use` content blocks that represent the model's use of those tools. You can then run those tools using the tool input generated by the model and then optionally return results back to the model using `tool_result` content blocks.
    ///
    ///There are two types of tools: **client tools** and **server tools**. The behavior described below applies to client tools. For [server tools](https://docs.claude.com/en/docs/agents-and-tools/tool-use/overview\#server-tools), see their individual documentation as each has its own behavior (e.g., the [web search tool](https://docs.claude.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
    ///
    ///Each tool definition includes:
    ///
    ///* `name`: Name of the tool.
    ///* `description`: Optional, but strongly-recommended description of the tool.
    ///* `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the tool `input` shape that the model will produce in `tool_use` output content blocks.
    ///
    ///For example, if you defined `tools` as:
    ///
    ///```json
    ///[
    ///  {
    ///    "name": "get_stock_price",
    ///    "description": "Get the current stock price for a given ticker symbol.",
    ///    "input_schema": {
    ///      "type": "object",
    ///      "properties": {
    ///        "ticker": {
    ///          "type": "string",
    ///          "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
    ///        }
    ///      },
    ///      "required": ["ticker"]
    ///    }
    ///  }
    ///]
    ///```
    ///
    ///And then asked the model "What's the S&P 500 at today?", the model might produce `tool_use` content blocks in the response like this:
    ///
    ///```json
    ///[
    ///  {
    ///    "type": "tool_use",
    ///    "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
    ///    "name": "get_stock_price",
    ///    "input": { "ticker": "^GSPC" }
    ///  }
    ///]
    ///```
    ///
    ///You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an input, and return the following back to the model in a subsequent `user` message:
    ///
    ///```json
    ///[
    ///  {
    ///    "type": "tool_result",
    ///    "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
    ///    "content": "259.75 USD"
    ///  }
    ///]
    ///```
    ///
    ///Tools can be used for workflows that include running client-side tools and functions, or more generally whenever you want the model to produce a particular JSON structure of output.
    ///
    ///See our [guide](https://docs.claude.com/en/docs/tool-use) for more details.
    pub tools: Option<Vec<BetaToolKind>>,
}
///System prompt.
///
///A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.claude.com/en/docs/system-prompts).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaCountMessageTokensParamsSystem {
    #[default]
    String(String),
    Array(Vec<BetaRequestTextBlock>),
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub struct BetaCountMessageTokensResponse {
    ///Information about context management applied to the message.
    pub context_management: Option<BetaContextManagementResponse>,
    ///The total number of tokens across the provided list of messages, system prompt, and tools.
    pub input_tokens: i64,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct BetaCreateMessageBatchParams {
    ///List of requests for prompt completion. Each is an individual request to create a Message.
    #[validate(length(min = 1u64, max = 10_000u64), nested)]
    pub requests: Vec<BetaMessageBatchIndividualRequestParams>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct BetaCreateMessageParams {
    ///Container identifier for reuse across requests.
    pub container: Option<BetaCreateMessageParamsContainer>,
    ///Context management configuration.
    ///
    ///This allows you to control how Claude manages context across multiple requests, such as whether to clear function results or not.
    #[validate(nested)]
    pub context_management: Option<BetaContextManagementConfig>,
    ///The maximum number of tokens to generate before stopping.
    ///
    ///Note that our models may stop _before_ reaching this maximum. This parameter only specifies the absolute maximum number of tokens to generate.
    ///
    ///Different models have different maximum values for this parameter.  See [models](https://docs.claude.com/en/docs/models-overview) for details.
    #[validate(range(min = 1i64))]
    pub max_tokens: i64,
    ///MCP servers to be utilized in this request
    #[validate(length(max = 20u64), nested)]
    pub mcp_servers: Option<Vec<BetaRequestMCPServerURLDefinition>>,
    ///Input messages.
    ///
    ///Our models are trained to operate on alternating `user` and `assistant` conversational turns. When creating a new `Message`, you specify the prior conversational turns with the `messages` parameter, and the model then generates the next `Message` in the conversation. Consecutive `user` or `assistant` turns in your request will be combined into a single turn.
    ///
    ///Each input message must be an object with a `role` and `content`. You can specify a single `user`-role message, or you can include multiple `user` and `assistant` messages.
    ///
    ///If the final message uses the `assistant` role, the response content will continue immediately from the content in that message. This can be used to constrain part of the model's response.
    ///
    ///Example with a single `user` message:
    ///
    ///```json
    ///[{"role": "user", "content": "Hello, Claude"}]
    ///```
    ///
    ///Example with multiple conversational turns:
    ///
    ///```json
    ///[
    ///  {"role": "user", "content": "Hello there."},
    ///  {"role": "assistant", "content": "Hi, I'm Claude. How can I help you?"},
    ///  {"role": "user", "content": "Can you explain LLMs in plain English?"},
    ///]
    ///```
    ///
    ///Example with a partially-filled response from Claude:
    ///
    ///```json
    ///[
    ///  {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
    ///  {"role": "assistant", "content": "The best answer is ("},
    ///]
    ///```
    ///
    ///Each input message `content` may be either a single `string` or an array of content blocks, where each block has a specific `type`. Using a `string` for `content` is shorthand for an array of one content block of type `"text"`. The following input messages are equivalent:
    ///
    ///```json
    ///{"role": "user", "content": "Hello, Claude"}
    ///```
    ///
    ///```json
    ///{"role": "user", "content": [{"type": "text", "text": "Hello, Claude"}]}
    ///```
    ///
    ///See [input examples](https://docs.claude.com/en/api/messages-examples).
    ///
    ///Note that if you want to include a [system prompt](https://docs.claude.com/en/docs/system-prompts), you can use the top-level `system` parameter  there is no `"system"` role for input messages in the Messages API.
    ///
    ///There is a limit of 100,000 messages in a single request.
    pub messages: Vec<BetaInputMessage>,
    pub metadata: Option<BetaMetadata>,
    ///The model that will complete your prompt.
    ///
    ///See [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
    pub model: Model,
    pub output_config: Option<BetaOutputConfig>,
    ///
    ///A schema to specify Claude's output format in responses.
    #[validate(nested)]
    pub output_format: Option<BetaJsonOutputFormat>,
    ///Determines whether to use priority capacity (if available) or standard capacity for this request.
    ///
    ///Anthropic offers different levels of service for your API requests. See [service-tiers](https://docs.claude.com/en/api/service-tiers) for details.
    pub service_tier: Option<ServiceTier>,
    ///Custom text sequences that will cause the model to stop generating.
    ///
    ///Our models will normally stop when they have naturally completed their turn, which will result in a response `stop_reason` of `"end_turn"`.
    ///
    ///If you want the model to stop generating when it encounters custom strings of text, you can use the `stop_sequences` parameter. If the model encounters one of the custom sequences, the response `stop_reason` value will be `"stop_sequence"` and the response `stop_sequence` value will contain the matched stop sequence.
    pub stop_sequences: Option<Vec<String>>,
    ///Whether to incrementally stream the response using server-sent events.
    ///
    ///See [streaming](https://docs.claude.com/en/api/messages-streaming) for details.
    pub stream: Option<bool>,
    ///System prompt.
    ///
    ///A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.claude.com/en/docs/system-prompts).
    pub system: Option<BetaCreateMessageParamsSystem>,
    ///Amount of randomness injected into the response.
    ///
    ///Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0` for analytical / multiple choice, and closer to `1.0` for creative and generative tasks.
    ///
    ///Note that even with `temperature` of `0.0`, the results will not be fully deterministic.
    #[validate(range(min = 0.0, max = 1.0))]
    pub temperature: Option<f64>,
    ///Configuration for enabling Claude's extended thinking.
    ///
    ///When enabled, responses include `thinking` content blocks showing Claude's thinking process before the final answer. Requires a minimum budget of 1,024 tokens and counts towards your `max_tokens` limit.
    ///
    ///See [extended thinking](https://docs.claude.com/en/docs/build-with-claude/extended-thinking) for details.
    pub thinking: Option<Box<BetaThinkingConfigParam>>,
    ///How the model should use the provided tools. The model can use a specific tool, any available tool, decide by itself, or not use tools at all.
    pub tool_choice: Option<Box<BetaToolChoice>>,
    ///Definitions of tools that the model may use.
    ///
    ///If you include `tools` in your API request, the model may return `tool_use` content blocks that represent the model's use of those tools. You can then run those tools using the tool input generated by the model and then optionally return results back to the model using `tool_result` content blocks.
    ///
    ///There are two types of tools: **client tools** and **server tools**. The behavior described below applies to client tools. For [server tools](https://docs.claude.com/en/docs/agents-and-tools/tool-use/overview\#server-tools), see their individual documentation as each has its own behavior (e.g., the [web search tool](https://docs.claude.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
    ///
    ///Each tool definition includes:
    ///
    ///* `name`: Name of the tool.
    ///* `description`: Optional, but strongly-recommended description of the tool.
    ///* `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the tool `input` shape that the model will produce in `tool_use` output content blocks.
    ///
    ///For example, if you defined `tools` as:
    ///
    ///```json
    ///[
    ///  {
    ///    "name": "get_stock_price",
    ///    "description": "Get the current stock price for a given ticker symbol.",
    ///    "input_schema": {
    ///      "type": "object",
    ///      "properties": {
    ///        "ticker": {
    ///          "type": "string",
    ///          "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
    ///        }
    ///      },
    ///      "required": ["ticker"]
    ///    }
    ///  }
    ///]
    ///```
    ///
    ///And then asked the model "What's the S&P 500 at today?", the model might produce `tool_use` content blocks in the response like this:
    ///
    ///```json
    ///[
    ///  {
    ///    "type": "tool_use",
    ///    "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
    ///    "name": "get_stock_price",
    ///    "input": { "ticker": "^GSPC" }
    ///  }
    ///]
    ///```
    ///
    ///You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an input, and return the following back to the model in a subsequent `user` message:
    ///
    ///```json
    ///[
    ///  {
    ///    "type": "tool_result",
    ///    "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
    ///    "content": "259.75 USD"
    ///  }
    ///]
    ///```
    ///
    ///Tools can be used for workflows that include running client-side tools and functions, or more generally whenever you want the model to produce a particular JSON structure of output.
    ///
    ///See our [guide](https://docs.claude.com/en/docs/tool-use) for more details.
    pub tools: Option<Vec<BetaToolKind>>,
    ///Only sample from the top K options for each subsequent token.
    ///
    ///Used to remove "long tail" low probability responses. [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
    ///
    ///Recommended for advanced use cases only. You usually only need to use `temperature`.
    #[validate(range(min = 0i64))]
    pub top_k: Option<i64>,
    ///Use nucleus sampling.
    ///
    ///In nucleus sampling, we compute the cumulative distribution over all the options for each subsequent token in decreasing probability order and cut it off once it reaches a particular probability specified by `top_p`. You should either alter `temperature` or `top_p`, but not both.
    ///
    ///Recommended for advanced use cases only. You usually only need to use `temperature`.
    #[validate(range(min = 0.0, max = 1.0))]
    pub top_p: Option<f64>,
}
///Container identifier for reuse across requests.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaCreateMessageParamsContainer {
    ///Container parameters with skills to be loaded.
    #[default]
    BetaContainerParams(BetaContainerParams),
    String(String),
}
impl BetaCreateMessageParamsContainer {
    ///Container parameters with skills to be loaded.
    pub fn beta_container_params() -> Self {
        Self::BetaContainerParams(BetaContainerParams::default())
    }
}
///System prompt.
///
///A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.claude.com/en/docs/system-prompts).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaCreateMessageParamsSystem {
    #[default]
    String(String),
    Array(Vec<BetaRequestTextBlock>),
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaCreateSkillResponse {
    ///ISO 8601 timestamp of when the skill was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Display title for the skill.
    ///
    ///This is a human-readable label that is not included in the prompt sent to the model.
    pub display_title: Option<String>,
    ///Unique identifier for the skill.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///The latest version identifier for the skill.
    ///
    ///This represents the most recent version of the skill that has been created.
    pub latest_version: Option<String>,
    ///Source of the skill.
    ///
    ///This may be one of the following values:
    ///* `"custom"`: the skill was created by a user
    ///* `"anthropic"`: the skill was created by Anthropic
    #[validate(length(min = 1u64))]
    pub source: String,
    ///Object type.
    ///
    ///For Skills, this is always `"skill"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill".to_string()))]
    pub r#type: Option<String>,
    ///ISO 8601 timestamp of when the skill was last updated.
    #[validate(length(min = 1u64))]
    pub updated_at: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaCreateSkillVersionResponse {
    ///ISO 8601 timestamp of when the skill version was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Description of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub description: String,
    ///Directory name of the skill version.
    ///
    ///This is the top-level directory name that was extracted from the uploaded files.
    #[validate(length(min = 1u64))]
    pub directory: String,
    ///Unique identifier for the skill version.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Human-readable name of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub name: String,
    ///Identifier for the skill that this version belongs to.
    #[validate(length(min = 1u64))]
    pub skill_id: String,
    ///Object type.
    ///
    ///For Skill Versions, this is always `"skill_version"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill_version".to_string()))]
    pub r#type: Option<String>,
    ///Version identifier for the skill.
    ///
    ///Each version is identified by a Unix epoch timestamp (e.g., "1759178010641129").
    #[validate(length(min = 1u64))]
    pub version: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaDeleteMessageBatchResponse {
    ///ID of the Message Batch.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Deleted object type.
    ///
    ///For Message Batches, this is always `"message_batch_deleted"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("message_batch_deleted".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaDeleteSkillResponse {
    ///Unique identifier for the skill.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Deleted object type.
    ///
    ///For Skills, this is always `"skill_deleted"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill_deleted".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaDeleteSkillVersionResponse {
    ///Version identifier for the skill.
    ///
    ///Each version is identified by a Unix epoch timestamp (e.g., "1759178010641129").
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Deleted object type.
    ///
    ///For Skill Versions, this is always `"skill_version_deleted"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill_version_deleted".to_string()))]
    pub r#type: Option<String>,
}
///Tool invocation directly from the model.
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaDirectCaller {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("direct".to_string())]
    pub r#type: String,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaEditKind {
    Thinking20251015(BetaResponseClearThinking20251015Edit),
    ToolUses20250919(BetaResponseClearToolUses20250919Edit),
}
impl BetaEditKind {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaEditKind {
    fn default() -> Self {
        Self::Thinking20251015(<BetaResponseClearThinking20251015Edit>::default())
    }
}
impl serde::Serialize for BetaEditKind {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Thinking20251015(v) => v.serialize(serializer),
            Self::ToolUses20250919(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaEditKind {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("clear_thinking_20251015") => serde_json::from_value(value)
                .map(Self::Thinking20251015)
                .map_err(serde::de::Error::custom),
            Some("clear_tool_uses_20250919") => serde_json::from_value(value)
                .map(Self::ToolUses20250919)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
///All possible effort levels.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaEffortLevel {
    #[serde(rename = "low")]
    #[default]
    Low,
    #[serde(rename = "medium")]
    Medium,
    #[serde(rename = "high")]
    High,
}
impl core::fmt::Display for BetaEffortLevel {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Low => write!(f, "low"),
            Self::Medium => write!(f, "medium"),
            Self::High => write!(f, "high"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaErrorResponse {
    pub error: BetaErrorResponseError,
    pub request_id: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaErrorResponseError {
    API(BetaAPIError),
    Authentication(BetaAuthenticationError),
    Billing(BetaBillingError),
    GatewayTimeout(BetaGatewayTimeoutError),
    InvalidRequest(BetaInvalidRequestError),
    NotFound(BetaNotFoundError),
    Overloaded(BetaOverloadedError),
    Permission(BetaPermissionError),
    RateLimit(BetaRateLimitError),
}
impl BetaErrorResponseError {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaErrorResponseError {
    fn default() -> Self {
        Self::API(<BetaAPIError>::default())
    }
}
impl serde::Serialize for BetaErrorResponseError {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::API(v) => v.serialize(serializer),
            Self::Authentication(v) => v.serialize(serializer),
            Self::Billing(v) => v.serialize(serializer),
            Self::GatewayTimeout(v) => v.serialize(serializer),
            Self::InvalidRequest(v) => v.serialize(serializer),
            Self::NotFound(v) => v.serialize(serializer),
            Self::Overloaded(v) => v.serialize(serializer),
            Self::Permission(v) => v.serialize(serializer),
            Self::RateLimit(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaErrorResponseError {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("api_error") => serde_json::from_value(value)
                .map(Self::API)
                .map_err(serde::de::Error::custom),
            Some("authentication_error") => serde_json::from_value(value)
                .map(Self::Authentication)
                .map_err(serde::de::Error::custom),
            Some("billing_error") => serde_json::from_value(value)
                .map(Self::Billing)
                .map_err(serde::de::Error::custom),
            Some("timeout_error") => serde_json::from_value(value)
                .map(Self::GatewayTimeout)
                .map_err(serde::de::Error::custom),
            Some("invalid_request_error") => serde_json::from_value(value)
                .map(Self::InvalidRequest)
                .map_err(serde::de::Error::custom),
            Some("not_found_error") => serde_json::from_value(value)
                .map(Self::NotFound)
                .map_err(serde::de::Error::custom),
            Some("overloaded_error") => serde_json::from_value(value)
                .map(Self::Overloaded)
                .map_err(serde::de::Error::custom),
            Some("permission_error") => serde_json::from_value(value)
                .map(Self::Permission)
                .map_err(serde::de::Error::custom),
            Some("rate_limit_error") => serde_json::from_value(value)
                .map(Self::RateLimit)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaErrorResponseError {
    pub fn invalid_request() -> Self {
        Self::InvalidRequest(BetaInvalidRequestError::default())
    }
    pub fn authentication() -> Self {
        Self::Authentication(BetaAuthenticationError::default())
    }
    pub fn billing() -> Self {
        Self::Billing(BetaBillingError::default())
    }
    pub fn permission() -> Self {
        Self::Permission(BetaPermissionError::default())
    }
    pub fn not_found() -> Self {
        Self::NotFound(BetaNotFoundError::default())
    }
    pub fn rate_limit() -> Self {
        Self::RateLimit(BetaRateLimitError::default())
    }
    pub fn gateway_timeout() -> Self {
        Self::GatewayTimeout(BetaGatewayTimeoutError::default())
    }
    pub fn api() -> Self {
        Self::API(BetaAPIError::default())
    }
    pub fn overloaded() -> Self {
        Self::Overloaded(BetaOverloadedError::default())
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaErroredResult {
    #[validate(nested)]
    pub error: BetaErrorResponse,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("errored".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaExpiredResult {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("expired".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaFileDeleteResponse {
    ///ID of the deleted file.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Deleted object type.
    ///
    ///For file deletion, this is always `"file_deleted"`.
    #[serde(rename = "type")]
    #[default(Some("file_deleted".to_string()))]
    pub r#type: Option<String>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaFileDocumentSource {
    #[validate(length(min = 1u64))]
    pub file_id: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("file".to_string())]
    pub r#type: String,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaFileImageSource {
    #[validate(length(min = 1u64))]
    pub file_id: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("file".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaFileListResponse {
    ///List of file metadata objects.
    #[validate(nested)]
    pub data: Vec<BetaFileMetadataSchema>,
    ///ID of the first file in this page of results.
    pub first_id: Option<String>,
    ///Whether there are more results available.
    #[default(Some(false))]
    pub has_more: Option<bool>,
    ///ID of the last file in this page of results.
    pub last_id: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaFileMetadataSchema {
    ///RFC 3339 datetime string representing when the file was created.
    pub created_at: chrono::DateTime<chrono::Utc>,
    ///Whether the file can be downloaded.
    #[default(Some(false))]
    pub downloadable: Option<bool>,
    ///Original filename of the uploaded file.
    #[validate(length(min = 1u64, max = 500u64))]
    pub filename: String,
    ///Unique object identifier.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///MIME type of the file.
    #[validate(length(min = 1u64, max = 255u64))]
    pub mime_type: String,
    ///Size of the file in bytes.
    #[validate(range(min = 0i64))]
    pub size_bytes: i64,
    ///Object type.
    ///
    ///For files, this is always `"file"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("file".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaGatewayTimeoutError {
    #[validate(length(min = 1u64))]
    #[default(Some("Request timeout".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("timeout_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaGetSkillResponse {
    ///ISO 8601 timestamp of when the skill was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Display title for the skill.
    ///
    ///This is a human-readable label that is not included in the prompt sent to the model.
    pub display_title: Option<String>,
    ///Unique identifier for the skill.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///The latest version identifier for the skill.
    ///
    ///This represents the most recent version of the skill that has been created.
    pub latest_version: Option<String>,
    ///Source of the skill.
    ///
    ///This may be one of the following values:
    ///* `"custom"`: the skill was created by a user
    ///* `"anthropic"`: the skill was created by Anthropic
    #[validate(length(min = 1u64))]
    pub source: String,
    ///Object type.
    ///
    ///For Skills, this is always `"skill"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill".to_string()))]
    pub r#type: Option<String>,
    ///ISO 8601 timestamp of when the skill was last updated.
    #[validate(length(min = 1u64))]
    pub updated_at: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaGetSkillVersionResponse {
    ///ISO 8601 timestamp of when the skill version was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Description of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub description: String,
    ///Directory name of the skill version.
    ///
    ///This is the top-level directory name that was extracted from the uploaded files.
    #[validate(length(min = 1u64))]
    pub directory: String,
    ///Unique identifier for the skill version.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Human-readable name of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub name: String,
    ///Identifier for the skill that this version belongs to.
    #[validate(length(min = 1u64))]
    pub skill_id: String,
    ///Object type.
    ///
    ///For Skill Versions, this is always `"skill_version"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill_version".to_string()))]
    pub r#type: Option<String>,
    ///Version identifier for the skill.
    ///
    ///Each version is identified by a Unix epoch timestamp (e.g., "1759178010641129").
    #[validate(length(min = 1u64))]
    pub version: String,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaInputContentBlock {
    BashCodeExecutionToolResult(BetaRequestBashCodeExecutionToolResultBlock),
    CodeExecutionToolResult(BetaRequestCodeExecutionToolResultBlock),
    ContainerUpload(BetaRequestContainerUploadBlock),
    Document(BetaRequestDocumentBlock),
    Image(BetaRequestImageBlock),
    MCPToolResult(BetaRequestMCPToolResultBlock),
    MCPToolUse(BetaRequestMCPToolUseBlock),
    RedactedThinking(BetaRequestRedactedThinkingBlock),
    SearchResult(BetaRequestSearchResultBlock),
    ServerToolUse(BetaRequestServerToolUseBlock),
    Text(BetaRequestTextBlock),
    TextEditorCodeExecutionToolResult(BetaRequestTextEditorCodeExecutionToolResultBlock),
    Thinking(BetaRequestThinkingBlock),
    ToolResult(BetaRequestToolResultBlock),
    ToolSearchToolResult(BetaRequestToolSearchToolResultBlock),
    ToolUse(BetaRequestToolUseBlock),
    WebFetchToolResult(BetaRequestWebFetchToolResultBlock),
    WebSearchToolResult(BetaRequestWebSearchToolResultBlock),
}
impl BetaInputContentBlock {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaInputContentBlock {
    fn default() -> Self {
        Self::BashCodeExecutionToolResult(<BetaRequestBashCodeExecutionToolResultBlock>::default())
    }
}
impl serde::Serialize for BetaInputContentBlock {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::BashCodeExecutionToolResult(v) => v.serialize(serializer),
            Self::CodeExecutionToolResult(v) => v.serialize(serializer),
            Self::ContainerUpload(v) => v.serialize(serializer),
            Self::Document(v) => v.serialize(serializer),
            Self::Image(v) => v.serialize(serializer),
            Self::MCPToolResult(v) => v.serialize(serializer),
            Self::MCPToolUse(v) => v.serialize(serializer),
            Self::RedactedThinking(v) => v.serialize(serializer),
            Self::SearchResult(v) => v.serialize(serializer),
            Self::ServerToolUse(v) => v.serialize(serializer),
            Self::Text(v) => v.serialize(serializer),
            Self::TextEditorCodeExecutionToolResult(v) => v.serialize(serializer),
            Self::Thinking(v) => v.serialize(serializer),
            Self::ToolResult(v) => v.serialize(serializer),
            Self::ToolSearchToolResult(v) => v.serialize(serializer),
            Self::ToolUse(v) => v.serialize(serializer),
            Self::WebFetchToolResult(v) => v.serialize(serializer),
            Self::WebSearchToolResult(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaInputContentBlock {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("bash_code_execution_tool_result") => serde_json::from_value(value)
                .map(Self::BashCodeExecutionToolResult)
                .map_err(serde::de::Error::custom),
            Some("code_execution_tool_result") => serde_json::from_value(value)
                .map(Self::CodeExecutionToolResult)
                .map_err(serde::de::Error::custom),
            Some("container_upload") => serde_json::from_value(value)
                .map(Self::ContainerUpload)
                .map_err(serde::de::Error::custom),
            Some("document") => serde_json::from_value(value)
                .map(Self::Document)
                .map_err(serde::de::Error::custom),
            Some("image") => serde_json::from_value(value)
                .map(Self::Image)
                .map_err(serde::de::Error::custom),
            Some("mcp_tool_result") => serde_json::from_value(value)
                .map(Self::MCPToolResult)
                .map_err(serde::de::Error::custom),
            Some("mcp_tool_use") => serde_json::from_value(value)
                .map(Self::MCPToolUse)
                .map_err(serde::de::Error::custom),
            Some("redacted_thinking") => serde_json::from_value(value)
                .map(Self::RedactedThinking)
                .map_err(serde::de::Error::custom),
            Some("search_result") => serde_json::from_value(value)
                .map(Self::SearchResult)
                .map_err(serde::de::Error::custom),
            Some("server_tool_use") => serde_json::from_value(value)
                .map(Self::ServerToolUse)
                .map_err(serde::de::Error::custom),
            Some("text") => serde_json::from_value(value)
                .map(Self::Text)
                .map_err(serde::de::Error::custom),
            Some("text_editor_code_execution_tool_result") => serde_json::from_value(value)
                .map(Self::TextEditorCodeExecutionToolResult)
                .map_err(serde::de::Error::custom),
            Some("thinking") => serde_json::from_value(value)
                .map(Self::Thinking)
                .map_err(serde::de::Error::custom),
            Some("tool_result") => serde_json::from_value(value)
                .map(Self::ToolResult)
                .map_err(serde::de::Error::custom),
            Some("tool_search_tool_result") => serde_json::from_value(value)
                .map(Self::ToolSearchToolResult)
                .map_err(serde::de::Error::custom),
            Some("tool_use") => serde_json::from_value(value)
                .map(Self::ToolUse)
                .map_err(serde::de::Error::custom),
            Some("web_fetch_tool_result") => serde_json::from_value(value)
                .map(Self::WebFetchToolResult)
                .map_err(serde::de::Error::custom),
            Some("web_search_tool_result") => serde_json::from_value(value)
                .map(Self::WebSearchToolResult)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaInputContentBlock {
    pub fn text(text: String) -> Self {
        Self::Text(BetaRequestTextBlock {
            text,
            ..Default::default()
        })
    }
    pub fn image(source: BetaRequestImageBlockSource) -> Self {
        Self::Image(BetaRequestImageBlock {
            source,
            ..Default::default()
        })
    }
    pub fn document(source: BetaRequestDocumentBlockSource) -> Self {
        Self::Document(BetaRequestDocumentBlock {
            source,
            ..Default::default()
        })
    }
    pub fn redacted_thinking(data: String) -> Self {
        Self::RedactedThinking(BetaRequestRedactedThinkingBlock {
            data,
            ..Default::default()
        })
    }
    pub fn tool_result(tool_use_id: String) -> Self {
        Self::ToolResult(BetaRequestToolResultBlock {
            tool_use_id,
            ..Default::default()
        })
    }
    pub fn mcp_tool_result(tool_use_id: String) -> Self {
        Self::MCPToolResult(BetaRequestMCPToolResultBlock {
            tool_use_id,
            ..Default::default()
        })
    }
    ///A content block that represents a file to be uploaded to the container
    ///Files uploaded via this block will be available in the container's input directory.
    pub fn container_upload(file_id: String) -> Self {
        Self::ContainerUpload(BetaRequestContainerUploadBlock {
            file_id,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaInputJsonContentBlockDelta {
    #[validate(length(min = 1u64))]
    pub partial_json: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("input_json_delta".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields)]
pub struct BetaInputMessage {
    pub content: BetaInputMessageContent,
    pub role: InputMessageRole,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaInputMessageContent {
    #[default]
    String(String),
    Array(Vec<BetaInputContentBlock>),
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaInputSchema {
    pub properties: Option<std::collections::HashMap<String, serde_json::Value>>,
    pub required: Option<Vec<String>>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("object".to_string())]
    pub r#type: String,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaInputTokensClearAtLeast {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("input_tokens".to_string())]
    pub r#type: String,
    #[validate(range(min = 0i64))]
    pub value: i64,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaInputTokensTrigger {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("input_tokens".to_string())]
    pub r#type: String,
    #[validate(range(min = 1i64))]
    pub value: i64,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaInvalidRequestError {
    #[validate(length(min = 1u64))]
    #[default(Some("Invalid request".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("invalid_request_error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaJsonOutputFormat {
    ///The JSON schema of the format
    pub schema: std::collections::HashMap<String, serde_json::Value>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("json_schema".to_string())]
    pub r#type: String,
}
pub type BetaJsonValue = serde_json::Value;
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct BetaListResponseMessageBatch {
    #[validate(nested)]
    pub data: Vec<BetaMessageBatch>,
    ///First ID in the `data` list. Can be used as the `before_id` for the previous page.
    pub first_id: Option<String>,
    ///Indicates if there are more results in the requested page direction.
    pub has_more: bool,
    ///Last ID in the `data` list. Can be used as the `after_id` for the next page.
    pub last_id: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct BetaListResponseModelInfo {
    #[validate(nested)]
    pub data: Vec<BetaModelInfo>,
    ///First ID in the `data` list. Can be used as the `before_id` for the previous page.
    pub first_id: Option<String>,
    ///Indicates if there are more results in the requested page direction.
    pub has_more: bool,
    ///Last ID in the `data` list. Can be used as the `after_id` for the next page.
    pub last_id: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct BetaListSkillVersionsResponse {
    ///List of skill versions.
    #[validate(nested)]
    pub data: Vec<BetaSkillVersion>,
    ///Indicates if there are more results in the requested page direction.
    pub has_more: bool,
    ///Token to provide in as `page` in the subsequent request to retrieve the next page of data.
    pub next_page: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct BetaListSkillsResponse {
    ///List of skills.
    #[validate(nested)]
    pub data: Vec<BetaapiSchemasSkillsSkill>,
    ///Whether there are more results available.
    ///
    ///If `true`, there are additional results that can be fetched using the `next_page` token.
    pub has_more: bool,
    ///Token for fetching the next page of results.
    ///
    ///If `null`, there are no more results available. Pass this value to the `page_token` parameter in the next request to get the next page.
    pub next_page: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaLocationCitationKind {
    Char(BetaRequestCharLocationCitation),
    ContentBlock(BetaRequestContentBlockLocationCitation),
    Page(BetaRequestPageLocationCitation),
    SearchResult(BetaRequestSearchResultLocationCitation),
    WebSearchResult(BetaRequestWebSearchResultLocationCitation),
}
impl BetaLocationCitationKind {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaLocationCitationKind {
    fn default() -> Self {
        Self::Char(<BetaRequestCharLocationCitation>::default())
    }
}
impl serde::Serialize for BetaLocationCitationKind {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Char(v) => v.serialize(serializer),
            Self::ContentBlock(v) => v.serialize(serializer),
            Self::Page(v) => v.serialize(serializer),
            Self::SearchResult(v) => v.serialize(serializer),
            Self::WebSearchResult(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaLocationCitationKind {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("char_location") => serde_json::from_value(value)
                .map(Self::Char)
                .map_err(serde::de::Error::custom),
            Some("content_block_location") => serde_json::from_value(value)
                .map(Self::ContentBlock)
                .map_err(serde::de::Error::custom),
            Some("page_location") => serde_json::from_value(value)
                .map(Self::Page)
                .map_err(serde::de::Error::custom),
            Some("search_result_location") => serde_json::from_value(value)
                .map(Self::SearchResult)
                .map_err(serde::de::Error::custom),
            Some("web_search_result_location") => serde_json::from_value(value)
                .map(Self::WebSearchResult)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
///Configuration for a specific tool in an MCP toolset.
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields)]
pub struct BetaMCPToolConfig {
    pub defer_loading: Option<bool>,
    pub enabled: Option<bool>,
}
///Default configuration for tools in an MCP toolset.
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields)]
pub struct BetaMCPToolDefaultConfig {
    pub defer_loading: Option<bool>,
    pub enabled: Option<bool>,
}
///Configuration for a group of tools from an MCP server.
///
///Allows configuring enabled status and defer_loading for all tools
///from an MCP server, with optional per-tool overrides.
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaMCPToolset {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///Configuration overrides for specific tools, keyed by tool name
    pub configs: Option<std::collections::HashMap<String, BetaMCPToolConfig>>,
    ///Default configuration for tools in an MCP toolset.
    pub default_config: Option<BetaMCPToolDefaultConfig>,
    ///Name of the MCP server to configure tools for
    #[validate(length(min = 1u64, max = 255u64))]
    pub mcp_server_name: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("mcp_toolset".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaMemoryTool20250818 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    pub input_examples: Option<Vec<std::collections::HashMap<String, BetaJsonValue>>>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("memory".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("memory_20250818".to_string())]
    pub r#type: String,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaMemoryTool20250818Command {
    Create(BetaMemoryTool20250818CreateCommand),
    Delete(BetaMemoryTool20250818DeleteCommand),
    Insert(BetaMemoryTool20250818InsertCommand),
    Rename(BetaMemoryTool20250818RenameCommand),
    StrReplace(BetaMemoryTool20250818StrReplaceCommand),
    View(BetaMemoryTool20250818ViewCommand),
}
impl BetaMemoryTool20250818Command {
    pub const DISCRIMINATOR_FIELD: &'static str = "command";
}
impl Default for BetaMemoryTool20250818Command {
    fn default() -> Self {
        Self::Create(<BetaMemoryTool20250818CreateCommand>::default())
    }
}
impl serde::Serialize for BetaMemoryTool20250818Command {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Create(v) => v.serialize(serializer),
            Self::Delete(v) => v.serialize(serializer),
            Self::Insert(v) => v.serialize(serializer),
            Self::Rename(v) => v.serialize(serializer),
            Self::StrReplace(v) => v.serialize(serializer),
            Self::View(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaMemoryTool20250818Command {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("create") => serde_json::from_value(value)
                .map(Self::Create)
                .map_err(serde::de::Error::custom),
            Some("delete") => serde_json::from_value(value)
                .map(Self::Delete)
                .map_err(serde::de::Error::custom),
            Some("insert") => serde_json::from_value(value)
                .map(Self::Insert)
                .map_err(serde::de::Error::custom),
            Some("rename") => serde_json::from_value(value)
                .map(Self::Rename)
                .map_err(serde::de::Error::custom),
            Some("str_replace") => serde_json::from_value(value)
                .map(Self::StrReplace)
                .map_err(serde::de::Error::custom),
            Some("view") => serde_json::from_value(value)
                .map(Self::View)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "command"
            ))),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaMemoryTool20250818CreateCommand {
    ///Command type identifier
    #[default(Some("create".to_string()))]
    pub command: Option<String>,
    ///Content to write to the file
    #[validate(length(min = 1u64))]
    pub file_text: String,
    ///Path where the file should be created
    #[validate(length(min = 1u64))]
    pub path: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaMemoryTool20250818DeleteCommand {
    ///Command type identifier
    #[default(Some("delete".to_string()))]
    pub command: Option<String>,
    ///Path to the file or directory to delete
    #[validate(length(min = 1u64))]
    pub path: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaMemoryTool20250818InsertCommand {
    ///Command type identifier
    #[default(Some("insert".to_string()))]
    pub command: Option<String>,
    ///Line number where text should be inserted
    #[validate(range(min = 1i64))]
    pub insert_line: i64,
    ///Text to insert at the specified line
    #[validate(length(min = 1u64))]
    pub insert_text: String,
    ///Path to the file where text should be inserted
    #[validate(length(min = 1u64))]
    pub path: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaMemoryTool20250818RenameCommand {
    ///Command type identifier
    #[default(Some("rename".to_string()))]
    pub command: Option<String>,
    ///New path for the file or directory
    #[validate(length(min = 1u64))]
    pub new_path: String,
    ///Current path of the file or directory
    #[validate(length(min = 1u64))]
    pub old_path: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaMemoryTool20250818StrReplaceCommand {
    ///Command type identifier
    #[default(Some("str_replace".to_string()))]
    pub command: Option<String>,
    ///Text to replace with
    #[validate(length(min = 1u64))]
    pub new_str: String,
    ///Text to search for and replace
    #[validate(length(min = 1u64))]
    pub old_str: String,
    ///Path to the file where text should be replaced
    #[validate(length(min = 1u64))]
    pub path: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaMemoryTool20250818ViewCommand {
    ///Command type identifier
    #[default(Some("view".to_string()))]
    pub command: Option<String>,
    ///Path to directory or file to view
    #[validate(length(min = 1u64))]
    pub path: String,
    ///Optional line range for viewing specific lines
    #[validate(length(min = 2u64, max = 2u64))]
    pub view_range: Option<Vec<i64>>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaMessage {
    ///Information about the container used in this request.
    ///
    ///This will be non-null if a container tool (e.g. code execution) was used.
    #[validate(nested)]
    pub container: Option<BetaContainer>,
    ///Content generated by the model.
    ///
    ///This is an array of content blocks, each of which has a `type` that determines its shape.
    ///
    ///Example:
    ///
    ///```json
    ///[{"type": "text", "text": "Hi, I'm Claude."}]
    ///```
    ///
    ///If the request input `messages` ended with an `assistant` turn, then the response `content` will continue directly from that last turn. You can use this to constrain the model's output.
    ///
    ///For example, if the input `messages` were:
    ///```json
    ///[
    ///  {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
    ///  {"role": "assistant", "content": "The best answer is ("}
    ///]
    ///```
    ///
    ///Then the response `content` might be:
    ///
    ///```json
    ///[{"type": "text", "text": "B)"}]
    ///```
    pub content: Vec<BetaContentBlock>,
    ///Context management response.
    ///
    ///Information about context management strategies applied during the request.
    pub context_management: Option<BetaResponseContextManagement>,
    ///Unique object identifier.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///The model that will complete your prompt.
    ///
    ///See [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
    pub model: Model,
    ///Conversational role of the generated message.
    ///
    ///This will always be `"assistant"`.
    #[validate(length(min = 1u64))]
    #[default(Some("assistant".to_string()))]
    pub role: Option<String>,
    ///The reason that we stopped.
    ///
    ///This may be one the following values:
    ///* `"end_turn"`: the model reached a natural stopping point
    ///* `"max_tokens"`: we exceeded the requested `max_tokens` or the model's maximum
    ///* `"stop_sequence"`: one of your provided custom `stop_sequences` was generated
    ///* `"tool_use"`: the model invoked one or more tools
    ///* `"pause_turn"`: we paused a long-running turn. You may provide the response back as-is in a subsequent request to let the model continue.
    ///* `"refusal"`: when streaming classifiers intervene to handle potential policy violations
    ///
    ///In non-streaming mode this value is always non-null. In streaming mode, it is null in the `message_start` event and non-null otherwise.
    pub stop_reason: Option<BetaStopReason>,
    ///Which custom stop sequence was generated, if any.
    ///
    ///This value will be a non-null string if one of your custom stop sequences was generated.
    pub stop_sequence: Option<String>,
    ///Object type.
    ///
    ///For Messages, this is always `"message"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("message".to_string()))]
    pub r#type: Option<String>,
    #[validate(nested)]
    pub usage: BetaUsage,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaMessageBatch {
    ///RFC 3339 datetime string representing the time at which the Message Batch was archived and its results became unavailable.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    ///RFC 3339 datetime string representing the time at which cancellation was initiated for the Message Batch. Specified only if cancellation was initiated.
    pub cancel_initiated_at: Option<chrono::DateTime<chrono::Utc>>,
    ///RFC 3339 datetime string representing the time at which the Message Batch was created.
    pub created_at: chrono::DateTime<chrono::Utc>,
    ///RFC 3339 datetime string representing the time at which processing for the Message Batch ended. Specified only once processing ends.
    ///
    ///Processing ends when every request in a Message Batch has either succeeded, errored, canceled, or expired.
    pub ended_at: Option<chrono::DateTime<chrono::Utc>>,
    ///RFC 3339 datetime string representing the time at which the Message Batch will expire and end processing, which is 24 hours after creation.
    pub expires_at: chrono::DateTime<chrono::Utc>,
    ///Unique object identifier.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Processing status of the Message Batch.
    pub processing_status: MessageBatchProcessingStatus,
    pub request_counts: BetaRequestCounts,
    ///URL to a `.jsonl` file containing the results of the Message Batch requests. Specified only once processing ends.
    ///
    ///Results in the file are not guaranteed to be in the same order as requests. Use the `custom_id` field to match results to requests.
    pub results_url: Option<String>,
    ///Object type.
    ///
    ///For Message Batches, this is always `"message_batch"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("message_batch".to_string()))]
    pub r#type: Option<String>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct BetaMessageBatchIndividualRequestParams {
    ///Developer-provided ID created for each request in a Message Batch. Useful for matching results to requests, as results may be given out of request order.
    ///
    ///Must be unique for each request within the Message Batch.
    #[validate(
        length(min = 1u64, max = 64u64),
        regex(path = "REGEX_BETA_MESSAGE_BATCH_INDIVIDUAL_REQUEST_PARAMS_CUSTOM_ID")
    )]
    pub custom_id: String,
    #[validate(nested)]
    pub params: BetaCreateMessageParams,
}
///This is a single line in the response `.jsonl` file and does not represent the response as a whole.
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct BetaMessageBatchIndividualResponse {
    ///Developer-provided ID created for each request in a Message Batch. Useful for matching results to requests, as results may be given out of request order.
    ///
    ///Must be unique for each request within the Message Batch.
    #[validate(length(min = 1u64))]
    pub custom_id: String,
    ///Processing result for this request.
    ///
    ///Contains a Message output if processing was successful, an error response if processing failed, or the reason why processing was not attempted, such as cancellation or expiration.
    pub result: BetaMessageBatchIndividualResponseResult,
}
///Processing result for this request.
///
///Contains a Message output if processing was successful, an error response if processing failed, or the reason why processing was not attempted, such as cancellation or expiration.
#[derive(Debug, Clone, PartialEq)]
pub enum BetaMessageBatchIndividualResponseResult {
    Canceled(BetaCanceledResult),
    Errored(BetaErroredResult),
    Expired(BetaExpiredResult),
    Succeeded(BetaSucceededResult),
}
impl BetaMessageBatchIndividualResponseResult {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaMessageBatchIndividualResponseResult {
    fn default() -> Self {
        Self::Canceled(<BetaCanceledResult>::default())
    }
}
impl serde::Serialize for BetaMessageBatchIndividualResponseResult {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Canceled(v) => v.serialize(serializer),
            Self::Errored(v) => v.serialize(serializer),
            Self::Expired(v) => v.serialize(serializer),
            Self::Succeeded(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaMessageBatchIndividualResponseResult {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("canceled") => serde_json::from_value(value)
                .map(Self::Canceled)
                .map_err(serde::de::Error::custom),
            Some("errored") => serde_json::from_value(value)
                .map(Self::Errored)
                .map_err(serde::de::Error::custom),
            Some("expired") => serde_json::from_value(value)
                .map(Self::Expired)
                .map_err(serde::de::Error::custom),
            Some("succeeded") => serde_json::from_value(value)
                .map(Self::Succeeded)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaMessageBatchIndividualResponseResult {
    pub fn succeeded(message: BetaMessage) -> Self {
        Self::Succeeded(BetaSucceededResult {
            message,
            ..Default::default()
        })
    }
    pub fn errored(error: BetaErrorResponse) -> Self {
        Self::Errored(BetaErroredResult {
            error,
            ..Default::default()
        })
    }
    pub fn canceled(r#type: Option<String>) -> Self {
        Self::Canceled(BetaCanceledResult {
            r#type,
            ..Default::default()
        })
    }
    pub fn expired(r#type: Option<String>) -> Self {
        Self::Expired(BetaExpiredResult {
            r#type,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct BetaMessageDelta {
    ///Information about the container used in this request.
    ///
    ///This will be non-null if a container tool (e.g. code execution) was used.
    #[validate(nested)]
    pub container: Option<BetaContainer>,
    pub stop_reason: Option<BetaStopReason>,
    pub stop_sequence: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaMessageDeltaEvent {
    ///Information about context management strategies applied during the request
    pub context_management: Option<BetaResponseContextManagement>,
    #[validate(nested)]
    pub delta: BetaMessageDelta,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("message_delta".to_string()))]
    pub r#type: Option<String>,
    #[validate(nested)]
    pub usage: BetaMessageDeltaUsage,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct BetaMessageDeltaUsage {
    ///The cumulative number of input tokens used to create the cache entry.
    pub cache_creation_input_tokens: Option<i64>,
    ///The cumulative number of input tokens read from the cache.
    pub cache_read_input_tokens: Option<i64>,
    ///The cumulative number of input tokens which were used.
    pub input_tokens: Option<i64>,
    ///The cumulative number of output tokens which were used.
    pub output_tokens: i64,
    ///The number of server tool requests.
    #[validate(nested)]
    pub server_tool_use: Option<BetaServerToolUsage>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaMessageStartEvent {
    #[validate(nested)]
    pub message: BetaMessage,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("message_start".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct BetaMessageStopEvent {
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("message_stop".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaMessageStreamEvent {
    ContentBlockDelta(BetaContentBlockDeltaEvent),
    ContentBlockStart(BetaContentBlockStartEvent),
    ContentBlockStop(BetaContentBlockStopEvent),
    MessageDelta(BetaMessageDeltaEvent),
    MessageStart(BetaMessageStartEvent),
    MessageStop(BetaMessageStopEvent),
}
impl BetaMessageStreamEvent {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaMessageStreamEvent {
    fn default() -> Self {
        Self::ContentBlockDelta(<BetaContentBlockDeltaEvent>::default())
    }
}
impl serde::Serialize for BetaMessageStreamEvent {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::ContentBlockDelta(v) => v.serialize(serializer),
            Self::ContentBlockStart(v) => v.serialize(serializer),
            Self::ContentBlockStop(v) => v.serialize(serializer),
            Self::MessageDelta(v) => v.serialize(serializer),
            Self::MessageStart(v) => v.serialize(serializer),
            Self::MessageStop(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaMessageStreamEvent {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("content_block_delta") => serde_json::from_value(value)
                .map(Self::ContentBlockDelta)
                .map_err(serde::de::Error::custom),
            Some("content_block_start") => serde_json::from_value(value)
                .map(Self::ContentBlockStart)
                .map_err(serde::de::Error::custom),
            Some("content_block_stop") => serde_json::from_value(value)
                .map(Self::ContentBlockStop)
                .map_err(serde::de::Error::custom),
            Some("message_delta") => serde_json::from_value(value)
                .map(Self::MessageDelta)
                .map_err(serde::de::Error::custom),
            Some("message_start") => serde_json::from_value(value)
                .map(Self::MessageStart)
                .map_err(serde::de::Error::custom),
            Some("message_stop") => serde_json::from_value(value)
                .map(Self::MessageStop)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaMessageStreamEvent {
    pub fn start(message: BetaMessage) -> Self {
        Self::MessageStart(BetaMessageStartEvent {
            message,
            ..Default::default()
        })
    }
    pub fn stop() -> Self {
        Self::MessageStop(BetaMessageStopEvent::default())
    }
    pub fn content_block_stop(index: i64) -> Self {
        Self::ContentBlockStop(BetaContentBlockStopEvent {
            index,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields)]
pub struct BetaMetadata {
    ///An external identifier for the user who is associated with the request.
    ///
    ///This should be a uuid, hash value, or other opaque identifier. Anthropic may use this id to help detect abuse. Do not include any identifying information such as name, email address, or phone number.
    pub user_id: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaModelInfo {
    ///RFC 3339 datetime string representing the time at which the model was released. May be set to an epoch value if the release date is unknown.
    pub created_at: chrono::DateTime<chrono::Utc>,
    ///A human-readable name for the model.
    #[validate(length(min = 1u64))]
    pub display_name: String,
    ///Unique model identifier.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Object type.
    ///
    ///For Models, this is always `"model"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("model".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaNotFoundError {
    #[validate(length(min = 1u64))]
    #[default(Some("Not found".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("not_found_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields)]
pub struct BetaOutputConfig {
    ///How much effort the model should put into its response. Higher effort levels may result in more thorough analysis but take longer.
    ///
    ///Valid values are `low`, `medium`, or `high`.
    pub effort: Option<BetaEffortLevel>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaOverloadedError {
    #[validate(length(min = 1u64))]
    #[default(Some("Overloaded".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("overloaded_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaPermissionError {
    #[validate(length(min = 1u64))]
    #[default(Some("Permission denied".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("permission_error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaPlainTextSource {
    #[validate(length(min = 1u64))]
    pub data: String,
    #[validate(length(min = 1u64))]
    #[default("text/plain".to_string())]
    pub media_type: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaRateLimitError {
    #[validate(length(min = 1u64))]
    #[default(Some("Rate limited".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("rate_limit_error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestBashCodeExecutionOutputBlock {
    #[validate(length(min = 1u64))]
    pub file_id: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("bash_code_execution_output".to_string())]
    pub r#type: String,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestBashCodeExecutionResultBlock {
    #[validate(nested)]
    pub content: Vec<BetaRequestBashCodeExecutionOutputBlock>,
    pub return_code: i64,
    #[validate(length(min = 1u64))]
    pub stderr: String,
    #[validate(length(min = 1u64))]
    pub stdout: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("bash_code_execution_result".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestBashCodeExecutionToolResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub content: BetaRequestBashCodeExecutionToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("bash_code_execution_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaRequestBashCodeExecutionToolResultBlockContent {
    #[default]
    ToolResultError(BetaRequestBashCodeExecutionToolResultError),
    ResultBlock(BetaRequestBashCodeExecutionResultBlock),
}
impl BetaRequestBashCodeExecutionToolResultBlockContent {
    pub fn error(error_code: BetaBashCodeExecutionToolResultErrorCode) -> Self {
        Self::ToolResultError(BetaRequestBashCodeExecutionToolResultError {
            error_code,
            ..Default::default()
        })
    }
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestBashCodeExecutionToolResultError {
    pub error_code: BetaBashCodeExecutionToolResultErrorCode,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("bash_code_execution_tool_result_error".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestCharLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_char_index: i64,
    #[validate(range(min = 0i64))]
    pub start_char_index: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("char_location".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields)]
pub struct BetaRequestCitationsConfig {
    pub enabled: Option<bool>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestCodeExecutionOutputBlock {
    #[validate(length(min = 1u64))]
    pub file_id: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("code_execution_output".to_string())]
    pub r#type: String,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestCodeExecutionResultBlock {
    #[validate(nested)]
    pub content: Vec<BetaRequestCodeExecutionOutputBlock>,
    pub return_code: i64,
    #[validate(length(min = 1u64))]
    pub stderr: String,
    #[validate(length(min = 1u64))]
    pub stdout: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("code_execution_result".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestCodeExecutionToolResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub content: BetaRequestCodeExecutionToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("code_execution_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaRequestCodeExecutionToolResultBlockContent {
    #[default]
    ToolResultError(BetaRequestCodeExecutionToolResultError),
    ResultBlock(BetaRequestCodeExecutionResultBlock),
}
impl BetaRequestCodeExecutionToolResultBlockContent {
    pub fn error(error_code: BetaCodeExecutionToolResultErrorCode) -> Self {
        Self::ToolResultError(BetaRequestCodeExecutionToolResultError {
            error_code,
            ..Default::default()
        })
    }
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestCodeExecutionToolResultError {
    pub error_code: BetaCodeExecutionToolResultErrorCode,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("code_execution_tool_result_error".to_string())]
    pub r#type: String,
}
///A content block that represents a file to be uploaded to the container
///Files uploaded via this block will be available in the container's input directory.
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestContainerUploadBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    #[validate(length(min = 1u64))]
    pub file_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("container_upload".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestContentBlockLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_block_index: i64,
    #[validate(range(min = 0i64))]
    pub start_block_index: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("content_block_location".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct BetaRequestCounts {
    ///Number of requests in the Message Batch that have been canceled.
    ///
    ///This is zero until processing of the entire Message Batch has ended.
    #[default(Some(0i64))]
    pub canceled: Option<i64>,
    ///Number of requests in the Message Batch that encountered an error.
    ///
    ///This is zero until processing of the entire Message Batch has ended.
    #[default(Some(0i64))]
    pub errored: Option<i64>,
    ///Number of requests in the Message Batch that have expired.
    ///
    ///This is zero until processing of the entire Message Batch has ended.
    #[default(Some(0i64))]
    pub expired: Option<i64>,
    ///Number of requests in the Message Batch that are processing.
    #[default(Some(0i64))]
    pub processing: Option<i64>,
    ///Number of requests in the Message Batch that have completed successfully.
    ///
    ///This is zero until processing of the entire Message Batch has ended.
    #[default(Some(0i64))]
    pub succeeded: Option<i64>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestDocumentBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub citations: Option<BetaRequestCitationsConfig>,
    pub context: Option<String>,
    pub source: BetaRequestDocumentBlockSource,
    pub title: Option<String>,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("document".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaRequestDocumentBlockSource {
    Base64PDF(BetaBase64PDFSource),
    ContentBlock(BetaContentBlockSource),
    FileDocument(BetaFileDocumentSource),
    PlainText(BetaPlainTextSource),
    URLPDF(BetaURLPDFSource),
}
impl BetaRequestDocumentBlockSource {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaRequestDocumentBlockSource {
    fn default() -> Self {
        Self::Base64PDF(<BetaBase64PDFSource>::default())
    }
}
impl serde::Serialize for BetaRequestDocumentBlockSource {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Base64PDF(v) => v.serialize(serializer),
            Self::ContentBlock(v) => v.serialize(serializer),
            Self::FileDocument(v) => v.serialize(serializer),
            Self::PlainText(v) => v.serialize(serializer),
            Self::URLPDF(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaRequestDocumentBlockSource {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("base64") => serde_json::from_value(value)
                .map(Self::Base64PDF)
                .map_err(serde::de::Error::custom),
            Some("content") => serde_json::from_value(value)
                .map(Self::ContentBlock)
                .map_err(serde::de::Error::custom),
            Some("file") => serde_json::from_value(value)
                .map(Self::FileDocument)
                .map_err(serde::de::Error::custom),
            Some("text") => serde_json::from_value(value)
                .map(Self::PlainText)
                .map_err(serde::de::Error::custom),
            Some("url") => serde_json::from_value(value)
                .map(Self::URLPDF)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaRequestDocumentBlockSource {
    pub fn base64pdf(data: Vec<u8>) -> Self {
        Self::Base64PDF(BetaBase64PDFSource {
            data,
            ..Default::default()
        })
    }
    pub fn plain_text(data: String) -> Self {
        Self::PlainText(BetaPlainTextSource {
            data,
            ..Default::default()
        })
    }
    pub fn content(content: BetaContentBlockSourceContent) -> Self {
        Self::ContentBlock(BetaContentBlockSource {
            content,
            ..Default::default()
        })
    }
    pub fn urlpdf(url: String) -> Self {
        Self::URLPDF(BetaURLPDFSource {
            url,
            ..Default::default()
        })
    }
    pub fn file(file_id: String) -> Self {
        Self::FileDocument(BetaFileDocumentSource {
            file_id,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestImageBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub source: BetaRequestImageBlockSource,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("image".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaRequestImageBlockSource {
    Base64(BetaBase64ImageSource),
    File(BetaFileImageSource),
    URL(BetaURLImageSource),
}
impl BetaRequestImageBlockSource {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaRequestImageBlockSource {
    fn default() -> Self {
        Self::Base64(<BetaBase64ImageSource>::default())
    }
}
impl serde::Serialize for BetaRequestImageBlockSource {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Base64(v) => v.serialize(serializer),
            Self::File(v) => v.serialize(serializer),
            Self::URL(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaRequestImageBlockSource {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("base64") => serde_json::from_value(value)
                .map(Self::Base64)
                .map_err(serde::de::Error::custom),
            Some("file") => serde_json::from_value(value)
                .map(Self::File)
                .map_err(serde::de::Error::custom),
            Some("url") => serde_json::from_value(value)
                .map(Self::URL)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaRequestImageBlockSource {
    pub fn url(url: String) -> Self {
        Self::URL(BetaURLImageSource {
            url,
            ..Default::default()
        })
    }
    pub fn file(file_id: String) -> Self {
        Self::File(BetaFileImageSource {
            file_id,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields)]
pub struct BetaRequestMCPServerToolConfiguration {
    pub allowed_tools: Option<Vec<String>>,
    pub enabled: Option<bool>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestMCPServerURLDefinition {
    pub authorization_token: Option<String>,
    #[validate(length(min = 1u64))]
    pub name: String,
    pub tool_configuration: Option<BetaRequestMCPServerToolConfiguration>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("url".to_string())]
    pub r#type: String,
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestMCPToolResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub content: Option<BetaRequestMCPToolResultBlockContent>,
    pub is_error: Option<bool>,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_MCPTOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("mcp_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaRequestMCPToolResultBlockContent {
    #[default]
    String(String),
    BetaMcpToolResultBlockParamContent(Vec<BetaRequestTextBlock>),
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestMCPToolUseBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_MCPTOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub id: String,
    pub input: std::collections::HashMap<String, serde_json::Value>,
    #[validate(length(min = 1u64))]
    pub name: String,
    ///The name of the MCP server
    #[validate(length(min = 1u64))]
    pub server_name: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("mcp_tool_use".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestPageLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_page_number: i64,
    #[validate(range(min = 1i64))]
    pub start_page_number: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("page_location".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestRedactedThinkingBlock {
    #[validate(length(min = 1u64))]
    pub data: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("redacted_thinking".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestSearchResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub citations: Option<BetaRequestCitationsConfig>,
    #[validate(nested)]
    pub content: Vec<BetaRequestTextBlock>,
    #[validate(length(min = 1u64))]
    pub source: String,
    #[validate(length(min = 1u64))]
    pub title: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("search_result".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestSearchResultLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    pub end_block_index: i64,
    #[validate(range(min = 0i64))]
    pub search_result_index: i64,
    #[validate(length(min = 1u64))]
    pub source: String,
    #[validate(range(min = 0i64))]
    pub start_block_index: i64,
    pub title: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("search_result_location".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestServerToolUseBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub caller: Option<ToolUseBlockCaller>,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub id: String,
    pub input: std::collections::HashMap<String, serde_json::Value>,
    pub name: ServerToolUseBlockName,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("server_tool_use".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestTextBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub citations: Option<BetaRequestTextBlockCitations>,
    #[validate(length(min = 1u64))]
    pub text: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("text".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaRequestTextBlockCitations {
    #[default]
    Array(Vec<BetaLocationCitationKind>),
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestTextEditorCodeExecutionCreateResultBlock {
    pub is_file_update: bool,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text_editor_code_execution_create_result".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestTextEditorCodeExecutionStrReplaceResultBlock {
    pub lines: Option<Vec<String>>,
    pub new_lines: Option<i64>,
    pub new_start: Option<i64>,
    pub old_lines: Option<i64>,
    pub old_start: Option<i64>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text_editor_code_execution_str_replace_result".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestTextEditorCodeExecutionToolResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub content: BetaRequestTextEditorCodeExecutionToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("text_editor_code_execution_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaRequestTextEditorCodeExecutionToolResultBlockContent {
    #[default]
    ToolResultError(BetaRequestTextEditorCodeExecutionToolResultError),
    ViewResultBlock(BetaRequestTextEditorCodeExecutionViewResultBlock),
    CreateResultBlock(BetaRequestTextEditorCodeExecutionCreateResultBlock),
    StrReplaceResultBlock(BetaRequestTextEditorCodeExecutionStrReplaceResultBlock),
}
impl BetaRequestTextEditorCodeExecutionToolResultBlockContent {
    pub fn error(error_code: BetaTextEditorCodeExecutionToolResultErrorCode) -> Self {
        Self::ToolResultError(BetaRequestTextEditorCodeExecutionToolResultError {
            error_code,
            ..Default::default()
        })
    }
    pub fn create(is_file_update: bool) -> Self {
        Self::CreateResultBlock(BetaRequestTextEditorCodeExecutionCreateResultBlock {
            is_file_update,
            ..Default::default()
        })
    }
    pub fn str_replace() -> Self {
        Self::StrReplaceResultBlock(
            BetaRequestTextEditorCodeExecutionStrReplaceResultBlock::default(),
        )
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestTextEditorCodeExecutionToolResultError {
    pub error_code: BetaTextEditorCodeExecutionToolResultErrorCode,
    pub error_message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text_editor_code_execution_tool_result_error".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestTextEditorCodeExecutionViewResultBlock {
    #[validate(length(min = 1u64))]
    pub content: String,
    pub file_type: TextEditorCodeExecutionViewResultBlockFileType,
    pub num_lines: Option<i64>,
    pub start_line: Option<i64>,
    pub total_lines: Option<i64>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text_editor_code_execution_view_result".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestThinkingBlock {
    #[validate(length(min = 1u64))]
    pub signature: String,
    #[validate(length(min = 1u64))]
    pub thinking: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("thinking".to_string()))]
    pub r#type: Option<String>,
}
///Tool reference block that can be included in tool_result content.
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestToolReferenceBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    #[validate(
        length(min = 1u64, max = 64u64),
        regex(path = "REGEX_BETA_MESSAGE_BATCH_INDIVIDUAL_REQUEST_PARAMS_CUSTOM_ID")
    )]
    pub tool_name: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("tool_reference".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestToolResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub content: Option<BetaRequestToolResultBlockContent>,
    pub is_error: Option<bool>,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_MCPTOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaRequestToolResultBlockContent {
    #[default]
    String(String),
    Array(Vec<BetaBlockKind2>),
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestToolSearchToolResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub content: BetaRequestToolSearchToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("tool_search_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaRequestToolSearchToolResultBlockContent {
    #[default]
    ResultError(BetaRequestToolSearchToolResultError),
    SearchResultBlock(BetaRequestToolSearchToolSearchResultBlock),
}
impl BetaRequestToolSearchToolResultBlockContent {
    pub fn error(error_code: BetaToolSearchToolResultErrorCode) -> Self {
        Self::ResultError(BetaRequestToolSearchToolResultError {
            error_code,
            ..Default::default()
        })
    }
    pub fn search_result_block(tool_references: Vec<BetaRequestToolReferenceBlock>) -> Self {
        Self::SearchResultBlock(BetaRequestToolSearchToolSearchResultBlock {
            tool_references,
            ..Default::default()
        })
    }
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestToolSearchToolResultError {
    pub error_code: BetaToolSearchToolResultErrorCode,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("tool_search_tool_result_error".to_string())]
    pub r#type: String,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestToolSearchToolSearchResultBlock {
    #[validate(nested)]
    pub tool_references: Vec<BetaRequestToolReferenceBlock>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("tool_search_tool_search_result".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestToolUseBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub caller: Option<ToolUseBlockCaller>,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_MCPTOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub id: String,
    pub input: std::collections::HashMap<String, serde_json::Value>,
    #[validate(length(min = 1u64, max = 200u64))]
    pub name: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("tool_use".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestWebFetchResultBlock {
    #[validate(nested)]
    pub content: BetaRequestDocumentBlock,
    ///ISO 8601 timestamp when the content was retrieved
    pub retrieved_at: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("web_fetch_result".to_string())]
    pub r#type: String,
    ///Fetched content URL
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestWebFetchToolResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub content: BetaRequestWebFetchToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("web_fetch_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaRequestWebFetchToolResultBlockContent {
    #[default]
    ToolResultError(BetaRequestWebFetchToolResultError),
    ResultBlock(BetaRequestWebFetchResultBlock),
}
impl BetaRequestWebFetchToolResultBlockContent {
    pub fn error(error_code: BetaWebFetchToolResultErrorCode) -> Self {
        Self::ToolResultError(BetaRequestWebFetchToolResultError {
            error_code,
            ..Default::default()
        })
    }
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestWebFetchToolResultError {
    pub error_code: BetaWebFetchToolResultErrorCode,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("web_fetch_tool_result_error".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestWebSearchResultBlock {
    #[validate(length(min = 1u64))]
    pub encrypted_content: String,
    pub page_age: Option<String>,
    #[validate(length(min = 1u64))]
    pub title: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("web_search_result".to_string())]
    pub r#type: String,
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestWebSearchResultLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(length(min = 1u64))]
    pub encrypted_index: String,
    pub title: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("web_search_result_location".to_string())]
    pub r#type: String,
    #[validate(length(min = 1u64, max = 2_048u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestWebSearchToolResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    pub content: BetaRequestWebSearchToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("web_search_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaRequestWebSearchToolResultBlockContent {
    #[default]
    ResultBlock(Vec<BetaRequestWebSearchResultBlock>),
    BetaRequestWebSearchToolResultError(BetaRequestWebSearchToolResultError),
}
impl BetaRequestWebSearchToolResultBlockContent {
    pub fn error(error_code: BetaWebSearchToolResultErrorCode) -> Self {
        Self::BetaRequestWebSearchToolResultError(BetaRequestWebSearchToolResultError {
            error_code,
            ..Default::default()
        })
    }
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaRequestWebSearchToolResultError {
    pub error_code: BetaWebSearchToolResultErrorCode,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("web_search_tool_result_error".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseBashCodeExecutionOutputBlock {
    #[validate(length(min = 1u64))]
    pub file_id: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("bash_code_execution_output".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseBashCodeExecutionResultBlock {
    #[validate(nested)]
    pub content: Vec<BetaResponseBashCodeExecutionOutputBlock>,
    pub return_code: i64,
    #[validate(length(min = 1u64))]
    pub stderr: String,
    #[validate(length(min = 1u64))]
    pub stdout: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("bash_code_execution_result".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseBashCodeExecutionToolResultBlock {
    pub content: BetaResponseBashCodeExecutionToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("bash_code_execution_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaResponseBashCodeExecutionToolResultBlockContent {
    #[default]
    ToolResultError(BetaResponseBashCodeExecutionToolResultError),
    ResultBlock(BetaResponseBashCodeExecutionResultBlock),
}
impl BetaResponseBashCodeExecutionToolResultBlockContent {
    pub fn error(error_code: BetaBashCodeExecutionToolResultErrorCode) -> Self {
        Self::ToolResultError(BetaResponseBashCodeExecutionToolResultError {
            error_code,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseBashCodeExecutionToolResultError {
    pub error_code: BetaBashCodeExecutionToolResultErrorCode,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("bash_code_execution_tool_result_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseCharLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_char_index: i64,
    pub file_id: Option<String>,
    #[validate(range(min = 0i64))]
    pub start_char_index: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("char_location".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct BetaResponseCitationsConfig {
    #[default(Some(false))]
    pub enabled: Option<bool>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseClearThinking20251015Edit {
    ///Number of input tokens cleared by this edit.
    #[validate(range(min = 0i64))]
    pub cleared_input_tokens: i64,
    ///Number of thinking turns that were cleared.
    #[validate(range(min = 0i64))]
    pub cleared_thinking_turns: i64,
    ///The type of context management edit applied.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("clear_thinking_20251015".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseClearToolUses20250919Edit {
    ///Number of input tokens cleared by this edit.
    #[validate(range(min = 0i64))]
    pub cleared_input_tokens: i64,
    ///Number of tool uses that were cleared.
    #[validate(range(min = 0i64))]
    pub cleared_tool_uses: i64,
    ///The type of context management edit applied.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("clear_tool_uses_20250919".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseCodeExecutionOutputBlock {
    #[validate(length(min = 1u64))]
    pub file_id: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("code_execution_output".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseCodeExecutionResultBlock {
    #[validate(nested)]
    pub content: Vec<BetaResponseCodeExecutionOutputBlock>,
    pub return_code: i64,
    #[validate(length(min = 1u64))]
    pub stderr: String,
    #[validate(length(min = 1u64))]
    pub stdout: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("code_execution_result".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseCodeExecutionToolResultBlock {
    pub content: BetaResponseCodeExecutionToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("code_execution_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaResponseCodeExecutionToolResultBlockContent {
    #[default]
    ToolResultError(BetaResponseCodeExecutionToolResultError),
    ResultBlock(BetaResponseCodeExecutionResultBlock),
}
impl BetaResponseCodeExecutionToolResultBlockContent {
    pub fn error(error_code: BetaCodeExecutionToolResultErrorCode) -> Self {
        Self::ToolResultError(BetaResponseCodeExecutionToolResultError {
            error_code,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseCodeExecutionToolResultError {
    pub error_code: BetaCodeExecutionToolResultErrorCode,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("code_execution_tool_result_error".to_string()))]
    pub r#type: Option<String>,
}
///Response model for a file uploaded to the container.
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseContainerUploadBlock {
    #[validate(length(min = 1u64))]
    pub file_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("container_upload".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseContentBlockLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_block_index: i64,
    pub file_id: Option<String>,
    #[validate(range(min = 0i64))]
    pub start_block_index: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("content_block_location".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub struct BetaResponseContextManagement {
    ///List of context management edits that were applied.
    pub applied_edits: Vec<BetaEditKind>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseDocumentBlock {
    ///Citation configuration for the document
    pub citations: Option<BetaResponseCitationsConfig>,
    pub source: BetaResponseDocumentBlockSource,
    ///The title of the document
    pub title: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("document".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaResponseDocumentBlockSource {
    Base64PDF(BetaBase64PDFSource),
    PlainText(BetaPlainTextSource),
}
impl BetaResponseDocumentBlockSource {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaResponseDocumentBlockSource {
    fn default() -> Self {
        Self::Base64PDF(<BetaBase64PDFSource>::default())
    }
}
impl serde::Serialize for BetaResponseDocumentBlockSource {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Base64PDF(v) => v.serialize(serializer),
            Self::PlainText(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaResponseDocumentBlockSource {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("base64") => serde_json::from_value(value)
                .map(Self::Base64PDF)
                .map_err(serde::de::Error::custom),
            Some("text") => serde_json::from_value(value)
                .map(Self::PlainText)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaResponseDocumentBlockSource {
    pub fn base64pdf(data: Vec<u8>) -> Self {
        Self::Base64PDF(BetaBase64PDFSource {
            data,
            ..Default::default()
        })
    }
    pub fn plain_text(data: String) -> Self {
        Self::PlainText(BetaPlainTextSource {
            data,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseMCPToolResultBlock {
    pub content: BetaResponseMCPToolResultBlockContent,
    #[default(Some(false))]
    pub is_error: Option<bool>,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_MCPTOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("mcp_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaResponseMCPToolResultBlockContent {
    #[default]
    String(String),
    BetaMcpToolResultBlockContent(Vec<BetaResponseTextBlock>),
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseMCPToolUseBlock {
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_MCPTOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub id: String,
    pub input: std::collections::HashMap<String, serde_json::Value>,
    ///The name of the MCP tool
    #[validate(length(min = 1u64))]
    pub name: String,
    ///The name of the MCP server
    #[validate(length(min = 1u64))]
    pub server_name: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("mcp_tool_use".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponsePageLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_page_number: i64,
    pub file_id: Option<String>,
    #[validate(range(min = 1i64))]
    pub start_page_number: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("page_location".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseRedactedThinkingBlock {
    #[validate(length(min = 1u64))]
    pub data: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("redacted_thinking".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseSearchResultLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    pub end_block_index: i64,
    #[validate(range(min = 0i64))]
    pub search_result_index: i64,
    #[validate(length(min = 1u64))]
    pub source: String,
    #[validate(range(min = 0i64))]
    pub start_block_index: i64,
    pub title: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("search_result_location".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseServerToolUseBlock {
    #[default(Some(Default::default()))]
    pub caller: Option<ToolUseBlockCaller>,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub id: String,
    pub input: std::collections::HashMap<String, serde_json::Value>,
    pub name: ServerToolUseBlockName,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("server_tool_use".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseTextBlock {
    ///Citations supporting the text block.
    ///
    ///The type of citation returned will depend on the type of document being cited. Citing a PDF results in `page_location`, plain text results in `char_location`, and content document results in `content_block_location`.
    pub citations: BetaResponseTextBlockCitations,
    #[validate(length(min = 0u64, max = 5_000_000u64))]
    pub text: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("text".to_string()))]
    pub r#type: Option<String>,
}
///Citations supporting the text block.
///
///The type of citation returned will depend on the type of document being cited. Citing a PDF results in `page_location`, plain text results in `char_location`, and content document results in `content_block_location`.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaResponseTextBlockCitations {
    #[default]
    Array(Vec<BetaCitationsDeltaCitation>),
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseTextEditorCodeExecutionCreateResultBlock {
    pub is_file_update: bool,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("text_editor_code_execution_create_result".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseTextEditorCodeExecutionStrReplaceResultBlock {
    pub lines: Option<Vec<String>>,
    pub new_lines: Option<i64>,
    pub new_start: Option<i64>,
    pub old_lines: Option<i64>,
    pub old_start: Option<i64>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("text_editor_code_execution_str_replace_result".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseTextEditorCodeExecutionToolResultBlock {
    pub content: BetaResponseTextEditorCodeExecutionToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("text_editor_code_execution_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaResponseTextEditorCodeExecutionToolResultBlockContent {
    #[default]
    ToolResultError(BetaResponseTextEditorCodeExecutionToolResultError),
    ViewResultBlock(BetaResponseTextEditorCodeExecutionViewResultBlock),
    CreateResultBlock(BetaResponseTextEditorCodeExecutionCreateResultBlock),
    StrReplaceResultBlock(BetaResponseTextEditorCodeExecutionStrReplaceResultBlock),
}
impl BetaResponseTextEditorCodeExecutionToolResultBlockContent {
    pub fn error(error_code: BetaTextEditorCodeExecutionToolResultErrorCode) -> Self {
        Self::ToolResultError(BetaResponseTextEditorCodeExecutionToolResultError {
            error_code,
            ..Default::default()
        })
    }
    pub fn create(is_file_update: bool) -> Self {
        Self::CreateResultBlock(BetaResponseTextEditorCodeExecutionCreateResultBlock {
            is_file_update,
            ..Default::default()
        })
    }
    pub fn str_replace() -> Self {
        Self::StrReplaceResultBlock(
            BetaResponseTextEditorCodeExecutionStrReplaceResultBlock::default(),
        )
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseTextEditorCodeExecutionToolResultError {
    pub error_code: BetaTextEditorCodeExecutionToolResultErrorCode,
    pub error_message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("text_editor_code_execution_tool_result_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseTextEditorCodeExecutionViewResultBlock {
    #[validate(length(min = 1u64))]
    pub content: String,
    pub file_type: TextEditorCodeExecutionViewResultBlockFileType,
    pub num_lines: Option<i64>,
    pub start_line: Option<i64>,
    pub total_lines: Option<i64>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("text_editor_code_execution_view_result".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseThinkingBlock {
    #[validate(length(min = 1u64))]
    pub signature: String,
    #[validate(length(min = 1u64))]
    pub thinking: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("thinking".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseToolReferenceBlock {
    #[validate(
        length(min = 1u64, max = 64u64),
        regex(path = "REGEX_BETA_MESSAGE_BATCH_INDIVIDUAL_REQUEST_PARAMS_CUSTOM_ID")
    )]
    pub tool_name: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("tool_reference".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseToolSearchToolResultBlock {
    pub content: BetaResponseToolSearchToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("tool_search_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaResponseToolSearchToolResultBlockContent {
    #[default]
    ResultError(BetaResponseToolSearchToolResultError),
    SearchResultBlock(BetaResponseToolSearchToolSearchResultBlock),
}
impl BetaResponseToolSearchToolResultBlockContent {
    pub fn error(error_code: BetaToolSearchToolResultErrorCode) -> Self {
        Self::ResultError(BetaResponseToolSearchToolResultError {
            error_code,
            ..Default::default()
        })
    }
    pub fn search_result_block(tool_references: Vec<BetaResponseToolReferenceBlock>) -> Self {
        Self::SearchResultBlock(BetaResponseToolSearchToolSearchResultBlock {
            tool_references,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseToolSearchToolResultError {
    pub error_code: BetaToolSearchToolResultErrorCode,
    pub error_message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("tool_search_tool_result_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseToolSearchToolSearchResultBlock {
    #[validate(nested)]
    pub tool_references: Vec<BetaResponseToolReferenceBlock>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("tool_search_tool_search_result".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseToolUseBlock {
    #[default(Some(Default::default()))]
    pub caller: Option<ToolUseBlockCaller>,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_MCPTOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub id: String,
    pub input: std::collections::HashMap<String, serde_json::Value>,
    #[validate(length(min = 1u64))]
    pub name: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("tool_use".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseWebFetchResultBlock {
    #[validate(nested)]
    pub content: BetaResponseDocumentBlock,
    ///ISO 8601 timestamp when the content was retrieved
    pub retrieved_at: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("web_fetch_result".to_string()))]
    pub r#type: Option<String>,
    ///Fetched content URL
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseWebFetchToolResultBlock {
    pub content: BetaResponseWebFetchToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("web_fetch_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaResponseWebFetchToolResultBlockContent {
    #[default]
    ToolResultError(BetaResponseWebFetchToolResultError),
    ResultBlock(BetaResponseWebFetchResultBlock),
}
impl BetaResponseWebFetchToolResultBlockContent {
    pub fn error(error_code: BetaWebFetchToolResultErrorCode) -> Self {
        Self::ToolResultError(BetaResponseWebFetchToolResultError {
            error_code,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseWebFetchToolResultError {
    pub error_code: BetaWebFetchToolResultErrorCode,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("web_fetch_tool_result_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseWebSearchResultBlock {
    #[validate(length(min = 1u64))]
    pub encrypted_content: String,
    pub page_age: Option<String>,
    #[validate(length(min = 1u64))]
    pub title: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("web_search_result".to_string()))]
    pub r#type: Option<String>,
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseWebSearchResultLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(length(min = 1u64))]
    pub encrypted_index: String,
    pub title: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("web_search_result_location".to_string()))]
    pub r#type: Option<String>,
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseWebSearchToolResultBlock {
    pub content: BetaResponseWebSearchToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("web_search_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaResponseWebSearchToolResultBlockContent {
    #[default]
    BetaResponseWebSearchToolResultError(BetaResponseWebSearchToolResultError),
    Array(Vec<BetaResponseWebSearchResultBlock>),
}
impl BetaResponseWebSearchToolResultBlockContent {
    pub fn error(error_code: BetaWebSearchToolResultErrorCode) -> Self {
        Self::BetaResponseWebSearchToolResultError(BetaResponseWebSearchToolResultError {
            error_code,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaResponseWebSearchToolResultError {
    pub error_code: BetaWebSearchToolResultErrorCode,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("web_search_tool_result_error".to_string()))]
    pub r#type: Option<String>,
}
///Tool invocation generated by a server-side tool.
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaServerToolCaller {
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_id: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("code_execution_20250825".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaServerToolUsage {
    ///The number of web fetch tool requests.
    #[validate(range(min = 0i64))]
    #[default(Some(0i64))]
    pub web_fetch_requests: Option<i64>,
    ///The number of web search tool requests.
    #[validate(range(min = 0i64))]
    #[default(Some(0i64))]
    pub web_search_requests: Option<i64>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaSignatureContentBlockDelta {
    #[validate(length(min = 1u64))]
    pub signature: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("signature_delta".to_string()))]
    pub r#type: Option<String>,
}
///A skill that was loaded in a container (response model).
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct BetaSkill {
    ///Skill ID
    #[validate(length(min = 1u64, max = 64u64))]
    pub skill_id: String,
    ///Type of skill - either 'anthropic' (built-in) or 'custom' (user-defined)
    #[serde(rename = "type")]
    pub r#type: BetaSkillParamsType,
    ///Skill version or 'latest' for most recent version
    #[validate(length(min = 1u64, max = 64u64))]
    pub version: String,
}
///Specification for a skill to be loaded in a container (request model).
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct BetaSkillParams {
    ///Skill ID
    #[validate(length(min = 1u64, max = 64u64))]
    pub skill_id: String,
    ///Type of skill - either 'anthropic' (built-in) or 'custom' (user-defined)
    #[serde(rename = "type")]
    pub r#type: BetaSkillParamsType,
    ///Skill version or 'latest' for most recent version
    #[validate(length(min = 1u64, max = 64u64))]
    pub version: Option<String>,
}
///Type of skill - either 'anthropic' (built-in) or 'custom' (user-defined)
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaSkillParamsType {
    #[serde(rename = "anthropic")]
    #[default]
    Anthropic,
    #[serde(rename = "custom")]
    Custom,
}
impl core::fmt::Display for BetaSkillParamsType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Anthropic => write!(f, "anthropic"),
            Self::Custom => write!(f, "custom"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaSkillVersion {
    ///ISO 8601 timestamp of when the skill version was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Description of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub description: String,
    ///Directory name of the skill version.
    ///
    ///This is the top-level directory name that was extracted from the uploaded files.
    #[validate(length(min = 1u64))]
    pub directory: String,
    ///Unique identifier for the skill version.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Human-readable name of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub name: String,
    ///Identifier for the skill that this version belongs to.
    #[validate(length(min = 1u64))]
    pub skill_id: String,
    ///Object type.
    ///
    ///For Skill Versions, this is always `"skill_version"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill_version".to_string()))]
    pub r#type: Option<String>,
    ///Version identifier for the skill.
    ///
    ///Each version is identified by a Unix epoch timestamp (e.g., "1759178010641129").
    #[validate(length(min = 1u64))]
    pub version: String,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaStopReason {
    #[serde(rename = "end_turn")]
    #[default]
    EndTurn,
    #[serde(rename = "max_tokens")]
    MaxTokens,
    #[serde(rename = "stop_sequence")]
    StopSequence,
    #[serde(rename = "tool_use")]
    ToolUse,
    #[serde(rename = "pause_turn")]
    PauseTurn,
    #[serde(rename = "refusal")]
    Refusal,
    #[serde(rename = "model_context_window_exceeded")]
    ModelContextWindowExceeded,
}
impl core::fmt::Display for BetaStopReason {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::EndTurn => write!(f, "end_turn"),
            Self::MaxTokens => write!(f, "max_tokens"),
            Self::StopSequence => write!(f, "stop_sequence"),
            Self::ToolUse => write!(f, "tool_use"),
            Self::PauseTurn => write!(f, "pause_turn"),
            Self::Refusal => write!(f, "refusal"),
            Self::ModelContextWindowExceeded => {
                write!(f, "model_context_window_exceeded")
            }
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaSucceededResult {
    #[validate(nested)]
    pub message: BetaMessage,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("succeeded".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaTextContentBlockDelta {
    #[validate(length(min = 1u64))]
    pub text: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("text_delta".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaTextEditor20241022 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    pub input_examples: Option<Vec<std::collections::HashMap<String, BetaJsonValue>>>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("str_replace_editor".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text_editor_20241022".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaTextEditor20250124 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    pub input_examples: Option<Vec<std::collections::HashMap<String, BetaJsonValue>>>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("str_replace_editor".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text_editor_20250124".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaTextEditor20250429 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    pub input_examples: Option<Vec<std::collections::HashMap<String, BetaJsonValue>>>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("str_replace_based_edit_tool".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text_editor_20250429".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaTextEditor20250728 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    pub input_examples: Option<Vec<std::collections::HashMap<String, BetaJsonValue>>>,
    ///Maximum number of characters to display when viewing a file. If not specified, defaults to displaying the full file.
    pub max_characters: Option<i64>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("str_replace_based_edit_tool".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text_editor_20250728".to_string())]
    pub r#type: String,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaTextEditorCodeExecutionToolResultErrorCode {
    #[serde(rename = "invalid_tool_input")]
    #[default]
    InvalidToolInput,
    #[serde(rename = "unavailable")]
    Unavailable,
    #[serde(rename = "too_many_requests")]
    TooManyRequests,
    #[serde(rename = "execution_time_exceeded")]
    ExecutionTimeExceeded,
    #[serde(rename = "file_not_found")]
    FileNotFound,
}
impl core::fmt::Display for BetaTextEditorCodeExecutionToolResultErrorCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::InvalidToolInput => write!(f, "invalid_tool_input"),
            Self::Unavailable => write!(f, "unavailable"),
            Self::TooManyRequests => write!(f, "too_many_requests"),
            Self::ExecutionTimeExceeded => write!(f, "execution_time_exceeded"),
            Self::FileNotFound => write!(f, "file_not_found"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields, default)]
pub struct BetaThinkingConfigDisabled {
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("disabled".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaThinkingConfigEnabled {
    ///Determines how many tokens Claude can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality.
    ///
    ///Must be 1024 and less than `max_tokens`.
    ///
    ///See [extended thinking](https://docs.claude.com/en/docs/build-with-claude/extended-thinking) for details.
    #[validate(range(min = 1_024i64))]
    pub budget_tokens: i64,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("enabled".to_string()))]
    pub r#type: Option<String>,
}
///Configuration for enabling Claude's extended thinking.
///
///When enabled, responses include `thinking` content blocks showing Claude's thinking process before the final answer. Requires a minimum budget of 1,024 tokens and counts towards your `max_tokens` limit.
///
///See [extended thinking](https://docs.claude.com/en/docs/build-with-claude/extended-thinking) for details.
#[derive(Debug, Clone, PartialEq)]
pub enum BetaThinkingConfigParam {
    Disabled(BetaThinkingConfigDisabled),
    Enabled(BetaThinkingConfigEnabled),
}
impl BetaThinkingConfigParam {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaThinkingConfigParam {
    fn default() -> Self {
        Self::Disabled(<BetaThinkingConfigDisabled>::default())
    }
}
impl serde::Serialize for BetaThinkingConfigParam {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Disabled(v) => v.serialize(serializer),
            Self::Enabled(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaThinkingConfigParam {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("disabled") => serde_json::from_value(value)
                .map(Self::Disabled)
                .map_err(serde::de::Error::custom),
            Some("enabled") => serde_json::from_value(value)
                .map(Self::Enabled)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaThinkingConfigParam {
    pub fn enabled(budget_tokens: i64) -> Self {
        Self::Enabled(BetaThinkingConfigEnabled {
            budget_tokens,
            ..Default::default()
        })
    }
    pub fn disabled() -> Self {
        Self::Disabled(BetaThinkingConfigDisabled::default())
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaThinkingContentBlockDelta {
    #[validate(length(min = 1u64))]
    pub thinking: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("thinking_delta".to_string()))]
    pub r#type: Option<String>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaThinkingTurns {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("thinking_turns".to_string())]
    pub r#type: String,
    #[validate(range(min = 1i64))]
    pub value: i64,
}
#[derive(Debug, Clone, PartialEq)]
pub enum BetaThinkingTurnsKind {
    All(BetaAllThinkingTurns),
    BetaThinkingTurns(BetaThinkingTurns),
}
impl BetaThinkingTurnsKind {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaThinkingTurnsKind {
    fn default() -> Self {
        Self::All(<BetaAllThinkingTurns>::default())
    }
}
impl serde::Serialize for BetaThinkingTurnsKind {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::All(v) => v.serialize(serializer),
            Self::BetaThinkingTurns(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaThinkingTurnsKind {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("all") => serde_json::from_value(value)
                .map(Self::All)
                .map_err(serde::de::Error::custom),
            Some("thinking_turns") => serde_json::from_value(value)
                .map(Self::BetaThinkingTurns)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaThinkingTurnsKind {
    pub fn beta_thinking_turns(value: i64) -> Self {
        Self::BetaThinkingTurns(BetaThinkingTurns {
            value,
            ..Default::default()
        })
    }
    pub fn all(r#type: String) -> Self {
        Self::All(BetaAllThinkingTurns {
            r#type,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct BetaTool {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    ///Description of what this tool does.
    ///
    ///Tool descriptions should be as detailed as possible. The more information that the model has about what the tool is and how to use it, the better it will perform. You can use natural language descriptions to reinforce important aspects of the tool input JSON schema.
    pub description: Option<String>,
    pub input_examples: Option<Vec<std::collections::HashMap<String, BetaJsonValue>>>,
    #[validate(nested)]
    pub input_schema: BetaInputSchema,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64, max = 128u64), regex(path = "REGEX_BETA_TOOL_NAME"))]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    pub r#type: Option<String>,
}
///How the model should use the provided tools. The model can use a specific tool, any available tool, decide by itself, or not use tools at all.
#[derive(Debug, Clone, PartialEq)]
pub enum BetaToolChoice {
    Any(BetaToolChoiceAny),
    Auto(BetaToolChoiceAuto),
    None(BetaToolChoiceNone),
    Tool(BetaToolChoiceTool),
}
impl BetaToolChoice {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for BetaToolChoice {
    fn default() -> Self {
        Self::Any(<BetaToolChoiceAny>::default())
    }
}
impl serde::Serialize for BetaToolChoice {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Any(v) => v.serialize(serializer),
            Self::Auto(v) => v.serialize(serializer),
            Self::None(v) => v.serialize(serializer),
            Self::Tool(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for BetaToolChoice {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("any") => serde_json::from_value(value)
                .map(Self::Any)
                .map_err(serde::de::Error::custom),
            Some("auto") => serde_json::from_value(value)
                .map(Self::Auto)
                .map_err(serde::de::Error::custom),
            Some("none") => serde_json::from_value(value)
                .map(Self::None)
                .map_err(serde::de::Error::custom),
            Some("tool") => serde_json::from_value(value)
                .map(Self::Tool)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl BetaToolChoice {
    ///The model will automatically decide whether to use tools.
    pub fn auto(disable_parallel_tool_use: Option<bool>) -> Self {
        Self::Auto(BetaToolChoiceAuto {
            disable_parallel_tool_use,
            ..Default::default()
        })
    }
    ///The model will use any available tools.
    pub fn any(disable_parallel_tool_use: Option<bool>) -> Self {
        Self::Any(BetaToolChoiceAny {
            disable_parallel_tool_use,
            ..Default::default()
        })
    }
    ///The model will use the specified tool with `tool_choice.name`.
    pub fn tool(name: String) -> Self {
        Self::Tool(BetaToolChoiceTool {
            name,
            ..Default::default()
        })
    }
    ///The model will not be allowed to use tools.
    pub fn none() -> Self {
        Self::None(BetaToolChoiceNone::default())
    }
}
///The model will use any available tools.
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields, default)]
pub struct BetaToolChoiceAny {
    ///Whether to disable parallel tool use.
    ///
    ///Defaults to `false`. If set to `true`, the model will output exactly one tool use.
    pub disable_parallel_tool_use: Option<bool>,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("any".to_string()))]
    pub r#type: Option<String>,
}
///The model will automatically decide whether to use tools.
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields, default)]
pub struct BetaToolChoiceAuto {
    ///Whether to disable parallel tool use.
    ///
    ///Defaults to `false`. If set to `true`, the model will output at most one tool use.
    pub disable_parallel_tool_use: Option<bool>,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("auto".to_string()))]
    pub r#type: Option<String>,
}
///The model will not be allowed to use tools.
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields, default)]
pub struct BetaToolChoiceNone {
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("none".to_string()))]
    pub r#type: Option<String>,
}
///The model will use the specified tool with `tool_choice.name`.
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaToolChoiceTool {
    ///Whether to disable parallel tool use.
    ///
    ///Defaults to `false`. If set to `true`, the model will output exactly one tool use.
    pub disable_parallel_tool_use: Option<bool>,
    ///The name of the tool to use.
    #[validate(length(min = 1u64))]
    pub name: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("tool".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum BetaToolKind {
    #[default]
    Tool(BetaTool),
    BashTool20241022(BetaBashTool20241022),
    BashTool20250124(BetaBashTool20250124),
    CodeExecutionTool20250522(BetaCodeExecutionTool20250522),
    CodeExecutionTool20250825(BetaCodeExecutionTool20250825),
    ComputerUseTool20241022(BetaComputerUseTool20241022),
    MemoryTool20250818(BetaMemoryTool20250818),
    ComputerUseTool20250124(BetaComputerUseTool20250124),
    TextEditor20241022(BetaTextEditor20241022),
    ComputerUseTool20251124(BetaComputerUseTool20251124),
    TextEditor20250124(BetaTextEditor20250124),
    TextEditor20250429(BetaTextEditor20250429),
    TextEditor20250728(BetaTextEditor20250728),
    WebSearchTool20250305(BetaWebSearchTool20250305),
    WebFetchTool20250910(BetaWebFetchTool20250910),
    ToolSearchToolBm2520251119(BetaToolSearchToolBm2520251119),
    ToolSearchToolRegex20251119(BetaToolSearchToolRegex20251119),
    ///Configuration for a group of tools from an MCP server.
    ///
    ///Allows configuring enabled status and defer_loading for all tools
    ///from an MCP server, with optional per-tool overrides.
    MCPToolset(BetaMCPToolset),
}
impl BetaToolKind {
    pub fn bash_tool20241022() -> Self {
        Self::BashTool20241022(BetaBashTool20241022::default())
    }
    pub fn bash_tool20250124() -> Self {
        Self::BashTool20250124(BetaBashTool20250124::default())
    }
    pub fn code_execution_tool20250522() -> Self {
        Self::CodeExecutionTool20250522(BetaCodeExecutionTool20250522::default())
    }
    pub fn code_execution_tool20250825() -> Self {
        Self::CodeExecutionTool20250825(BetaCodeExecutionTool20250825::default())
    }
    ///Configuration for a group of tools from an MCP server.
    ///
    ///Allows configuring enabled status and defer_loading for all tools
    ///from an MCP server, with optional per-tool overrides.
    pub fn mcp_toolset(mcp_server_name: String) -> Self {
        Self::MCPToolset(BetaMCPToolset {
            mcp_server_name,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaToolSearchToolBm2520251119 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("tool_search_tool_bm25".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    pub r#type: BetaToolSearchToolBm2520251119Type,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaToolSearchToolBm2520251119Type {
    #[serde(rename = "tool_search_tool_bm25_20251119")]
    #[default]
    ToolSearchToolBm2520251119,
    #[serde(rename = "tool_search_tool_bm25")]
    ToolSearchToolBm25,
}
impl core::fmt::Display for BetaToolSearchToolBm2520251119Type {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ToolSearchToolBm2520251119 => {
                write!(f, "tool_search_tool_bm25_20251119")
            }
            Self::ToolSearchToolBm25 => write!(f, "tool_search_tool_bm25"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaToolSearchToolRegex20251119 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("tool_search_tool_regex".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    pub r#type: BetaToolSearchToolRegex20251119Type,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaToolSearchToolRegex20251119Type {
    #[serde(rename = "tool_search_tool_regex_20251119")]
    #[default]
    ToolSearchToolRegex20251119,
    #[serde(rename = "tool_search_tool_regex")]
    ToolSearchToolRegex,
}
impl core::fmt::Display for BetaToolSearchToolRegex20251119Type {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ToolSearchToolRegex20251119 => {
                write!(f, "tool_search_tool_regex_20251119")
            }
            Self::ToolSearchToolRegex => write!(f, "tool_search_tool_regex"),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaToolSearchToolResultErrorCode {
    #[serde(rename = "invalid_tool_input")]
    #[default]
    InvalidToolInput,
    #[serde(rename = "unavailable")]
    Unavailable,
    #[serde(rename = "too_many_requests")]
    TooManyRequests,
    #[serde(rename = "execution_time_exceeded")]
    ExecutionTimeExceeded,
}
impl core::fmt::Display for BetaToolSearchToolResultErrorCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::InvalidToolInput => write!(f, "invalid_tool_input"),
            Self::Unavailable => write!(f, "unavailable"),
            Self::TooManyRequests => write!(f, "too_many_requests"),
            Self::ExecutionTimeExceeded => write!(f, "execution_time_exceeded"),
        }
    }
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaToolUsesKeep {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("tool_uses".to_string())]
    pub r#type: String,
    #[validate(range(min = 0i64))]
    pub value: i64,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaToolUsesTrigger {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("tool_uses".to_string())]
    pub r#type: String,
    #[validate(range(min = 1i64))]
    pub value: i64,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaURLImageSource {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("url".to_string())]
    pub r#type: String,
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaURLPDFSource {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("url".to_string())]
    pub r#type: String,
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct BetaUsage {
    ///Breakdown of cached tokens by TTL
    #[validate(nested)]
    pub cache_creation: Option<BetaCacheCreation>,
    ///The number of input tokens used to create the cache entry.
    pub cache_creation_input_tokens: Option<i64>,
    ///The number of input tokens read from the cache.
    pub cache_read_input_tokens: Option<i64>,
    ///The number of input tokens which were used.
    #[validate(range(min = 0i64))]
    pub input_tokens: i64,
    ///The number of output tokens which were used.
    #[validate(range(min = 0i64))]
    pub output_tokens: i64,
    ///The number of server tool requests.
    #[validate(nested)]
    pub server_tool_use: Option<BetaServerToolUsage>,
    ///If the request used the priority, standard, or batch tier.
    pub service_tier: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaUserLocation {
    ///The city of the user.
    pub city: Option<String>,
    ///The two letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the user.
    pub country: Option<String>,
    ///The region of the user.
    pub region: Option<String>,
    ///The [IANA timezone](https://nodatime.org/TimeZones) of the user.
    pub timezone: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("approximate".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaWebFetchTool20250910 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///List of domains to allow fetching from
    pub allowed_domains: Option<Vec<String>>,
    ///List of domains to block fetching from
    pub blocked_domains: Option<Vec<String>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///Citations configuration for fetched documents. Citations are disabled by default.
    pub citations: Option<BetaRequestCitationsConfig>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    ///Maximum number of tokens used by including web page text content in the context. The limit is approximate and does not apply to binary content such as PDFs.
    pub max_content_tokens: Option<i64>,
    ///Maximum number of times the tool can be used in the API request.
    pub max_uses: Option<i64>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("web_fetch".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("web_fetch_20250910".to_string())]
    pub r#type: String,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaWebFetchToolResultErrorCode {
    #[serde(rename = "invalid_tool_input")]
    #[default]
    InvalidToolInput,
    #[serde(rename = "url_too_long")]
    UrlTooLong,
    #[serde(rename = "url_not_allowed")]
    UrlNotAllowed,
    #[serde(rename = "url_not_accessible")]
    UrlNotAccessible,
    #[serde(rename = "unsupported_content_type")]
    UnsupportedContentType,
    #[serde(rename = "too_many_requests")]
    TooManyRequests,
    #[serde(rename = "max_uses_exceeded")]
    MaxUsesExceeded,
    #[serde(rename = "unavailable")]
    Unavailable,
}
impl core::fmt::Display for BetaWebFetchToolResultErrorCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::InvalidToolInput => write!(f, "invalid_tool_input"),
            Self::UrlTooLong => write!(f, "url_too_long"),
            Self::UrlNotAllowed => write!(f, "url_not_allowed"),
            Self::UrlNotAccessible => write!(f, "url_not_accessible"),
            Self::UnsupportedContentType => write!(f, "unsupported_content_type"),
            Self::TooManyRequests => write!(f, "too_many_requests"),
            Self::MaxUsesExceeded => write!(f, "max_uses_exceeded"),
            Self::Unavailable => write!(f, "unavailable"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct BetaWebSearchTool20250305 {
    pub allowed_callers: Option<Vec<BetaBashTool20241022AllowedCaller>>,
    ///If provided, only these domains will be included in results. Cannot be used alongside `blocked_domains`.
    pub allowed_domains: Option<Vec<String>>,
    ///If provided, these domains will never appear in results. Cannot be used alongside `allowed_domains`.
    pub blocked_domains: Option<Vec<String>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<BetaCacheControlEphemeral>,
    ///If true, tool will not be included in initial system prompt. Only loaded when returned via tool_reference from tool search.
    pub defer_loading: Option<bool>,
    ///Maximum number of times the tool can be used in the API request.
    pub max_uses: Option<i64>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("web_search".to_string())]
    pub name: String,
    pub strict: Option<bool>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("web_search_20250305".to_string())]
    pub r#type: String,
    ///Parameters for the user's location. Used to provide more relevant search results.
    #[validate(nested)]
    pub user_location: Option<BetaUserLocation>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum BetaWebSearchToolResultErrorCode {
    #[serde(rename = "invalid_tool_input")]
    #[default]
    InvalidToolInput,
    #[serde(rename = "unavailable")]
    Unavailable,
    #[serde(rename = "max_uses_exceeded")]
    MaxUsesExceeded,
    #[serde(rename = "too_many_requests")]
    TooManyRequests,
    #[serde(rename = "query_too_long")]
    QueryTooLong,
}
impl core::fmt::Display for BetaWebSearchToolResultErrorCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::InvalidToolInput => write!(f, "invalid_tool_input"),
            Self::Unavailable => write!(f, "unavailable"),
            Self::MaxUsesExceeded => write!(f, "max_uses_exceeded"),
            Self::TooManyRequests => write!(f, "too_many_requests"),
            Self::QueryTooLong => write!(f, "query_too_long"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BetaapiSchemasSkillsSkill {
    ///ISO 8601 timestamp of when the skill was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Display title for the skill.
    ///
    ///This is a human-readable label that is not included in the prompt sent to the model.
    pub display_title: Option<String>,
    ///Unique identifier for the skill.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///The latest version identifier for the skill.
    ///
    ///This represents the most recent version of the skill that has been created.
    pub latest_version: Option<String>,
    ///Source of the skill.
    ///
    ///This may be one of the following values:
    ///* `"custom"`: the skill was created by a user
    ///* `"anthropic"`: the skill was created by Anthropic
    #[validate(length(min = 1u64))]
    pub source: String,
    ///Object type.
    ///
    ///For Skills, this is always `"skill"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill".to_string()))]
    pub r#type: Option<String>,
    ///ISO 8601 timestamp of when the skill was last updated.
    #[validate(length(min = 1u64))]
    pub updated_at: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct BillingError {
    #[validate(length(min = 1u64))]
    #[default(Some("Billing error".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("billing_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub struct BodyCreateSkillV1SkillsPost {
    ///Display title for the skill.
    ///
    ///This is a human-readable label that is not included in the prompt sent to the model.
    pub display_title: Option<String>,
    ///Files to upload for the skill.
    ///
    ///All files must be in the same top-level directory and must include a SKILL.md file at the root of that directory.
    pub files: Option<Vec<Vec<u8>>>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub struct BodyCreateSkillVersionV1SkillsSkillIdVersionsPost {
    ///Files to upload for the skill.
    ///
    ///All files must be in the same top-level directory and must include a SKILL.md file at the root of that directory.
    pub files: Option<Vec<Vec<u8>>>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct CacheControlEphemeral {
    ///The time-to-live for the cache control breakpoint.
    ///
    ///This may be one the following values:
    ///- `5m`: 5 minutes
    ///- `1h`: 1 hour
    ///
    ///Defaults to `5m`.
    pub ttl: Option<CacheControlEphemeralTtl>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("ephemeral".to_string())]
    pub r#type: String,
}
///The time-to-live for the cache control breakpoint.
///
///This may be one the following values:
///- `5m`: 5 minutes
///- `1h`: 1 hour
///
///Defaults to `5m`.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum CacheControlEphemeralTtl {
    #[serde(rename = "5m")]
    #[default]
    T5m,
    #[serde(rename = "1h")]
    T1h,
}
impl core::fmt::Display for CacheControlEphemeralTtl {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::T5m => write!(f, "5m"),
            Self::T1h => write!(f, "1h"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct CacheCreation {
    ///The number of input tokens used to create the 1 hour cache entry.
    #[validate(range(min = 0i64))]
    #[default(Some(0i64))]
    pub ephemeral_1h_input_tokens: Option<i64>,
    ///The number of input tokens used to create the 5 minute cache entry.
    #[validate(range(min = 0i64))]
    #[default(Some(0i64))]
    pub ephemeral_5m_input_tokens: Option<i64>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct CanceledResult {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("canceled".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct CitationsDelta {
    pub citation: CitationsDeltaCitation,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("citations_delta".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum CitationsDeltaCitation {
    Char(ResponseCharLocationCitation),
    ContentBlock(ResponseContentBlockLocationCitation),
    Page(ResponsePageLocationCitation),
    SearchResult(ResponseSearchResultLocationCitation),
    WebSearchResult(ResponseWebSearchResultLocationCitation),
}
impl CitationsDeltaCitation {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for CitationsDeltaCitation {
    fn default() -> Self {
        Self::Char(<ResponseCharLocationCitation>::default())
    }
}
impl serde::Serialize for CitationsDeltaCitation {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Char(v) => v.serialize(serializer),
            Self::ContentBlock(v) => v.serialize(serializer),
            Self::Page(v) => v.serialize(serializer),
            Self::SearchResult(v) => v.serialize(serializer),
            Self::WebSearchResult(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for CitationsDeltaCitation {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("char_location") => serde_json::from_value(value)
                .map(Self::Char)
                .map_err(serde::de::Error::custom),
            Some("content_block_location") => serde_json::from_value(value)
                .map(Self::ContentBlock)
                .map_err(serde::de::Error::custom),
            Some("page_location") => serde_json::from_value(value)
                .map(Self::Page)
                .map_err(serde::de::Error::custom),
            Some("search_result_location") => serde_json::from_value(value)
                .map(Self::SearchResult)
                .map_err(serde::de::Error::custom),
            Some("web_search_result_location") => serde_json::from_value(value)
                .map(Self::WebSearchResult)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct CompletionRequest {
    ///The maximum number of tokens to generate before stopping.
    ///
    ///Note that our models may stop _before_ reaching this maximum. This parameter only specifies the absolute maximum number of tokens to generate.
    #[validate(range(min = 1i64))]
    pub max_tokens_to_sample: i64,
    pub metadata: Option<Metadata>,
    ///The model that will complete your prompt.
    ///
    ///See [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
    pub model: Model,
    ///The prompt that you want Claude to complete.
    ///
    ///For proper response generation you will need to format your prompt using alternating `
    ///
    ///Human:` and `
    ///
    ///Assistant:` conversational turns. For example:
    ///
    ///```text
    ///"
    ///
    ///Human: {userQuestion}
    ///
    ///Assistant:"
    ///```
    ///
    ///See [prompt validation](https://docs.claude.com/en/api/prompt-validation) and our guide to [prompt design](https://docs.claude.com/en/docs/intro-to-prompting) for more details.
    #[validate(length(min = 1u64))]
    pub prompt: String,
    ///Sequences that will cause the model to stop generating.
    ///
    ///Our models stop on `"
    ///
    ///Human:"`, and may include additional built-in stop sequences in the future. By providing the stop_sequences parameter, you may include additional strings that will cause the model to stop generating.
    pub stop_sequences: Option<Vec<String>>,
    ///Whether to incrementally stream the response using server-sent events.
    ///
    ///See [streaming](https://docs.claude.com/en/api/streaming) for details.
    pub stream: Option<bool>,
    ///Amount of randomness injected into the response.
    ///
    ///Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0` for analytical / multiple choice, and closer to `1.0` for creative and generative tasks.
    ///
    ///Note that even with `temperature` of `0.0`, the results will not be fully deterministic.
    #[validate(range(min = 0.0, max = 1.0))]
    pub temperature: Option<f64>,
    ///Only sample from the top K options for each subsequent token.
    ///
    ///Used to remove "long tail" low probability responses. [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
    ///
    ///Recommended for advanced use cases only. You usually only need to use `temperature`.
    #[validate(range(min = 0i64))]
    pub top_k: Option<i64>,
    ///Use nucleus sampling.
    ///
    ///In nucleus sampling, we compute the cumulative distribution over all the options for each subsequent token in decreasing probability order and cut it off once it reaches a particular probability specified by `top_p`. You should either alter `temperature` or `top_p`, but not both.
    ///
    ///Recommended for advanced use cases only. You usually only need to use `temperature`.
    #[validate(range(min = 0.0, max = 1.0))]
    pub top_p: Option<f64>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct CompletionResponse {
    ///The resulting completion up to and excluding the stop sequences.
    #[validate(length(min = 1u64))]
    pub completion: String,
    ///Unique object identifier.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///The model that will complete your prompt.
    ///
    ///See [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
    pub model: Model,
    ///The reason that we stopped.
    ///
    ///This may be one the following values:
    ///* `"stop_sequence"`: we reached a stop sequence  either provided by you via the `stop_sequences` parameter, or a stop sequence built into the model
    ///* `"max_tokens"`: we exceeded `max_tokens_to_sample` or the model's maximum
    pub stop_reason: Option<String>,
    ///Object type.
    ///
    ///For Text Completions, this is always `"completion"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("completion".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum ContentBlock {
    RedactedThinking(ResponseRedactedThinkingBlock),
    ServerToolUse(ResponseServerToolUseBlock),
    Text(ResponseTextBlock),
    Thinking(ResponseThinkingBlock),
    ToolUse(ResponseToolUseBlock),
    WebSearchToolResult(ResponseWebSearchToolResultBlock),
}
impl ContentBlock {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for ContentBlock {
    fn default() -> Self {
        Self::RedactedThinking(<ResponseRedactedThinkingBlock>::default())
    }
}
impl serde::Serialize for ContentBlock {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::RedactedThinking(v) => v.serialize(serializer),
            Self::ServerToolUse(v) => v.serialize(serializer),
            Self::Text(v) => v.serialize(serializer),
            Self::Thinking(v) => v.serialize(serializer),
            Self::ToolUse(v) => v.serialize(serializer),
            Self::WebSearchToolResult(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for ContentBlock {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("redacted_thinking") => serde_json::from_value(value)
                .map(Self::RedactedThinking)
                .map_err(serde::de::Error::custom),
            Some("server_tool_use") => serde_json::from_value(value)
                .map(Self::ServerToolUse)
                .map_err(serde::de::Error::custom),
            Some("text") => serde_json::from_value(value)
                .map(Self::Text)
                .map_err(serde::de::Error::custom),
            Some("thinking") => serde_json::from_value(value)
                .map(Self::Thinking)
                .map_err(serde::de::Error::custom),
            Some("tool_use") => serde_json::from_value(value)
                .map(Self::ToolUse)
                .map_err(serde::de::Error::custom),
            Some("web_search_tool_result") => serde_json::from_value(value)
                .map(Self::WebSearchToolResult)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl ContentBlock {
    pub fn redacted_thinking(data: String) -> Self {
        Self::RedactedThinking(ResponseRedactedThinkingBlock {
            data,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct ContentBlockDeltaEvent {
    pub delta: ContentBlockDeltaEventDelta,
    pub index: i64,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("content_block_delta".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum ContentBlockDeltaEventDelta {
    Citations(CitationsDelta),
    InputJsonContentBlock(InputJsonContentBlockDelta),
    SignatureContentBlock(SignatureContentBlockDelta),
    TextContentBlock(TextContentBlockDelta),
    ThinkingContentBlock(ThinkingContentBlockDelta),
}
impl ContentBlockDeltaEventDelta {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for ContentBlockDeltaEventDelta {
    fn default() -> Self {
        Self::Citations(<CitationsDelta>::default())
    }
}
impl serde::Serialize for ContentBlockDeltaEventDelta {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Citations(v) => v.serialize(serializer),
            Self::InputJsonContentBlock(v) => v.serialize(serializer),
            Self::SignatureContentBlock(v) => v.serialize(serializer),
            Self::TextContentBlock(v) => v.serialize(serializer),
            Self::ThinkingContentBlock(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for ContentBlockDeltaEventDelta {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("citations_delta") => serde_json::from_value(value)
                .map(Self::Citations)
                .map_err(serde::de::Error::custom),
            Some("input_json_delta") => serde_json::from_value(value)
                .map(Self::InputJsonContentBlock)
                .map_err(serde::de::Error::custom),
            Some("signature_delta") => serde_json::from_value(value)
                .map(Self::SignatureContentBlock)
                .map_err(serde::de::Error::custom),
            Some("text_delta") => serde_json::from_value(value)
                .map(Self::TextContentBlock)
                .map_err(serde::de::Error::custom),
            Some("thinking_delta") => serde_json::from_value(value)
                .map(Self::ThinkingContentBlock)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl ContentBlockDeltaEventDelta {
    pub fn text(text: String) -> Self {
        Self::TextContentBlock(TextContentBlockDelta {
            text,
            ..Default::default()
        })
    }
    pub fn input_json(partial_json: String) -> Self {
        Self::InputJsonContentBlock(InputJsonContentBlockDelta {
            partial_json,
            ..Default::default()
        })
    }
    pub fn citations(citation: CitationsDeltaCitation) -> Self {
        Self::Citations(CitationsDelta {
            citation,
            ..Default::default()
        })
    }
    pub fn thinking(thinking: String) -> Self {
        Self::ThinkingContentBlock(ThinkingContentBlockDelta {
            thinking,
            ..Default::default()
        })
    }
    pub fn signature(signature: String) -> Self {
        Self::SignatureContentBlock(SignatureContentBlockDelta {
            signature,
            ..Default::default()
        })
    }
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct ContentBlockSource {
    pub content: ContentBlockSourceContent,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("content".to_string())]
    pub r#type: String,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum ContentBlockSourceContent {
    #[default]
    String(String),
    ContentBlockSourceContent(Vec<RequestBlockKind>),
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct ContentBlockStartEvent {
    pub content_block: Box<ContentBlock>,
    pub index: i64,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("content_block_start".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct ContentBlockStopEvent {
    pub index: i64,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("content_block_stop".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields)]
pub struct CountMessageTokensParams {
    ///Input messages.
    ///
    ///Our models are trained to operate on alternating `user` and `assistant` conversational turns. When creating a new `Message`, you specify the prior conversational turns with the `messages` parameter, and the model then generates the next `Message` in the conversation. Consecutive `user` or `assistant` turns in your request will be combined into a single turn.
    ///
    ///Each input message must be an object with a `role` and `content`. You can specify a single `user`-role message, or you can include multiple `user` and `assistant` messages.
    ///
    ///If the final message uses the `assistant` role, the response content will continue immediately from the content in that message. This can be used to constrain part of the model's response.
    ///
    ///Example with a single `user` message:
    ///
    ///```json
    ///[{"role": "user", "content": "Hello, Claude"}]
    ///```
    ///
    ///Example with multiple conversational turns:
    ///
    ///```json
    ///[
    ///  {"role": "user", "content": "Hello there."},
    ///  {"role": "assistant", "content": "Hi, I'm Claude. How can I help you?"},
    ///  {"role": "user", "content": "Can you explain LLMs in plain English?"},
    ///]
    ///```
    ///
    ///Example with a partially-filled response from Claude:
    ///
    ///```json
    ///[
    ///  {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
    ///  {"role": "assistant", "content": "The best answer is ("},
    ///]
    ///```
    ///
    ///Each input message `content` may be either a single `string` or an array of content blocks, where each block has a specific `type`. Using a `string` for `content` is shorthand for an array of one content block of type `"text"`. The following input messages are equivalent:
    ///
    ///```json
    ///{"role": "user", "content": "Hello, Claude"}
    ///```
    ///
    ///```json
    ///{"role": "user", "content": [{"type": "text", "text": "Hello, Claude"}]}
    ///```
    ///
    ///See [input examples](https://docs.claude.com/en/api/messages-examples).
    ///
    ///Note that if you want to include a [system prompt](https://docs.claude.com/en/docs/system-prompts), you can use the top-level `system` parameter  there is no `"system"` role for input messages in the Messages API.
    ///
    ///There is a limit of 100,000 messages in a single request.
    pub messages: Vec<InputMessage>,
    ///The model that will complete your prompt.
    ///
    ///See [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
    pub model: Model,
    ///System prompt.
    ///
    ///A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.claude.com/en/docs/system-prompts).
    pub system: Option<System>,
    ///Configuration for enabling Claude's extended thinking.
    ///
    ///When enabled, responses include `thinking` content blocks showing Claude's thinking process before the final answer. Requires a minimum budget of 1,024 tokens and counts towards your `max_tokens` limit.
    ///
    ///See [extended thinking](https://docs.claude.com/en/docs/build-with-claude/extended-thinking) for details.
    pub thinking: Option<Box<ThinkingConfigParam>>,
    ///How the model should use the provided tools. The model can use a specific tool, any available tool, decide by itself, or not use tools at all.
    pub tool_choice: Option<Box<ToolChoice>>,
    ///Definitions of tools that the model may use.
    ///
    ///If you include `tools` in your API request, the model may return `tool_use` content blocks that represent the model's use of those tools. You can then run those tools using the tool input generated by the model and then optionally return results back to the model using `tool_result` content blocks.
    ///
    ///There are two types of tools: **client tools** and **server tools**. The behavior described below applies to client tools. For [server tools](https://docs.claude.com/en/docs/agents-and-tools/tool-use/overview\#server-tools), see their individual documentation as each has its own behavior (e.g., the [web search tool](https://docs.claude.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
    ///
    ///Each tool definition includes:
    ///
    ///* `name`: Name of the tool.
    ///* `description`: Optional, but strongly-recommended description of the tool.
    ///* `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the tool `input` shape that the model will produce in `tool_use` output content blocks.
    ///
    ///For example, if you defined `tools` as:
    ///
    ///```json
    ///[
    ///  {
    ///    "name": "get_stock_price",
    ///    "description": "Get the current stock price for a given ticker symbol.",
    ///    "input_schema": {
    ///      "type": "object",
    ///      "properties": {
    ///        "ticker": {
    ///          "type": "string",
    ///          "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
    ///        }
    ///      },
    ///      "required": ["ticker"]
    ///    }
    ///  }
    ///]
    ///```
    ///
    ///And then asked the model "What's the S&P 500 at today?", the model might produce `tool_use` content blocks in the response like this:
    ///
    ///```json
    ///[
    ///  {
    ///    "type": "tool_use",
    ///    "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
    ///    "name": "get_stock_price",
    ///    "input": { "ticker": "^GSPC" }
    ///  }
    ///]
    ///```
    ///
    ///You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an input, and return the following back to the model in a subsequent `user` message:
    ///
    ///```json
    ///[
    ///  {
    ///    "type": "tool_result",
    ///    "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
    ///    "content": "259.75 USD"
    ///  }
    ///]
    ///```
    ///
    ///Tools can be used for workflows that include running client-side tools and functions, or more generally whenever you want the model to produce a particular JSON structure of output.
    ///
    ///See our [guide](https://docs.claude.com/en/docs/tool-use) for more details.
    pub tools: Option<Vec<ToolKind>>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub struct CountMessageTokensResponse {
    ///The total number of tokens across the provided list of messages, system prompt, and tools.
    pub input_tokens: i64,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct CreateMessageBatchParams {
    ///List of requests for prompt completion. Each is an individual request to create a Message.
    #[validate(length(min = 1u64, max = 10_000u64), nested)]
    pub requests: Vec<MessageBatchIndividualRequestParams>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct CreateMessageParams {
    ///The maximum number of tokens to generate before stopping.
    ///
    ///Note that our models may stop _before_ reaching this maximum. This parameter only specifies the absolute maximum number of tokens to generate.
    ///
    ///Different models have different maximum values for this parameter.  See [models](https://docs.claude.com/en/docs/models-overview) for details.
    #[validate(range(min = 1i64))]
    pub max_tokens: i64,
    ///Input messages.
    ///
    ///Our models are trained to operate on alternating `user` and `assistant` conversational turns. When creating a new `Message`, you specify the prior conversational turns with the `messages` parameter, and the model then generates the next `Message` in the conversation. Consecutive `user` or `assistant` turns in your request will be combined into a single turn.
    ///
    ///Each input message must be an object with a `role` and `content`. You can specify a single `user`-role message, or you can include multiple `user` and `assistant` messages.
    ///
    ///If the final message uses the `assistant` role, the response content will continue immediately from the content in that message. This can be used to constrain part of the model's response.
    ///
    ///Example with a single `user` message:
    ///
    ///```json
    ///[{"role": "user", "content": "Hello, Claude"}]
    ///```
    ///
    ///Example with multiple conversational turns:
    ///
    ///```json
    ///[
    ///  {"role": "user", "content": "Hello there."},
    ///  {"role": "assistant", "content": "Hi, I'm Claude. How can I help you?"},
    ///  {"role": "user", "content": "Can you explain LLMs in plain English?"},
    ///]
    ///```
    ///
    ///Example with a partially-filled response from Claude:
    ///
    ///```json
    ///[
    ///  {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
    ///  {"role": "assistant", "content": "The best answer is ("},
    ///]
    ///```
    ///
    ///Each input message `content` may be either a single `string` or an array of content blocks, where each block has a specific `type`. Using a `string` for `content` is shorthand for an array of one content block of type `"text"`. The following input messages are equivalent:
    ///
    ///```json
    ///{"role": "user", "content": "Hello, Claude"}
    ///```
    ///
    ///```json
    ///{"role": "user", "content": [{"type": "text", "text": "Hello, Claude"}]}
    ///```
    ///
    ///See [input examples](https://docs.claude.com/en/api/messages-examples).
    ///
    ///Note that if you want to include a [system prompt](https://docs.claude.com/en/docs/system-prompts), you can use the top-level `system` parameter  there is no `"system"` role for input messages in the Messages API.
    ///
    ///There is a limit of 100,000 messages in a single request.
    pub messages: Vec<InputMessage>,
    pub metadata: Option<Metadata>,
    ///The model that will complete your prompt.
    ///
    ///See [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
    pub model: Model,
    ///Determines whether to use priority capacity (if available) or standard capacity for this request.
    ///
    ///Anthropic offers different levels of service for your API requests. See [service-tiers](https://docs.claude.com/en/api/service-tiers) for details.
    pub service_tier: Option<ServiceTier>,
    ///Custom text sequences that will cause the model to stop generating.
    ///
    ///Our models will normally stop when they have naturally completed their turn, which will result in a response `stop_reason` of `"end_turn"`.
    ///
    ///If you want the model to stop generating when it encounters custom strings of text, you can use the `stop_sequences` parameter. If the model encounters one of the custom sequences, the response `stop_reason` value will be `"stop_sequence"` and the response `stop_sequence` value will contain the matched stop sequence.
    pub stop_sequences: Option<Vec<String>>,
    ///Whether to incrementally stream the response using server-sent events.
    ///
    ///See [streaming](https://docs.claude.com/en/api/messages-streaming) for details.
    pub stream: Option<bool>,
    ///System prompt.
    ///
    ///A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.claude.com/en/docs/system-prompts).
    pub system: Option<CreateMessageParamsSystem>,
    ///Amount of randomness injected into the response.
    ///
    ///Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0` for analytical / multiple choice, and closer to `1.0` for creative and generative tasks.
    ///
    ///Note that even with `temperature` of `0.0`, the results will not be fully deterministic.
    #[validate(range(min = 0.0, max = 1.0))]
    pub temperature: Option<f64>,
    ///Configuration for enabling Claude's extended thinking.
    ///
    ///When enabled, responses include `thinking` content blocks showing Claude's thinking process before the final answer. Requires a minimum budget of 1,024 tokens and counts towards your `max_tokens` limit.
    ///
    ///See [extended thinking](https://docs.claude.com/en/docs/build-with-claude/extended-thinking) for details.
    pub thinking: Option<Box<ThinkingConfigParam>>,
    ///How the model should use the provided tools. The model can use a specific tool, any available tool, decide by itself, or not use tools at all.
    pub tool_choice: Option<Box<ToolChoice>>,
    ///Definitions of tools that the model may use.
    ///
    ///If you include `tools` in your API request, the model may return `tool_use` content blocks that represent the model's use of those tools. You can then run those tools using the tool input generated by the model and then optionally return results back to the model using `tool_result` content blocks.
    ///
    ///There are two types of tools: **client tools** and **server tools**. The behavior described below applies to client tools. For [server tools](https://docs.claude.com/en/docs/agents-and-tools/tool-use/overview\#server-tools), see their individual documentation as each has its own behavior (e.g., the [web search tool](https://docs.claude.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
    ///
    ///Each tool definition includes:
    ///
    ///* `name`: Name of the tool.
    ///* `description`: Optional, but strongly-recommended description of the tool.
    ///* `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the tool `input` shape that the model will produce in `tool_use` output content blocks.
    ///
    ///For example, if you defined `tools` as:
    ///
    ///```json
    ///[
    ///  {
    ///    "name": "get_stock_price",
    ///    "description": "Get the current stock price for a given ticker symbol.",
    ///    "input_schema": {
    ///      "type": "object",
    ///      "properties": {
    ///        "ticker": {
    ///          "type": "string",
    ///          "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
    ///        }
    ///      },
    ///      "required": ["ticker"]
    ///    }
    ///  }
    ///]
    ///```
    ///
    ///And then asked the model "What's the S&P 500 at today?", the model might produce `tool_use` content blocks in the response like this:
    ///
    ///```json
    ///[
    ///  {
    ///    "type": "tool_use",
    ///    "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
    ///    "name": "get_stock_price",
    ///    "input": { "ticker": "^GSPC" }
    ///  }
    ///]
    ///```
    ///
    ///You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an input, and return the following back to the model in a subsequent `user` message:
    ///
    ///```json
    ///[
    ///  {
    ///    "type": "tool_result",
    ///    "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
    ///    "content": "259.75 USD"
    ///  }
    ///]
    ///```
    ///
    ///Tools can be used for workflows that include running client-side tools and functions, or more generally whenever you want the model to produce a particular JSON structure of output.
    ///
    ///See our [guide](https://docs.claude.com/en/docs/tool-use) for more details.
    pub tools: Option<Vec<ToolKind>>,
    ///Only sample from the top K options for each subsequent token.
    ///
    ///Used to remove "long tail" low probability responses. [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
    ///
    ///Recommended for advanced use cases only. You usually only need to use `temperature`.
    #[validate(range(min = 0i64))]
    pub top_k: Option<i64>,
    ///Use nucleus sampling.
    ///
    ///In nucleus sampling, we compute the cumulative distribution over all the options for each subsequent token in decreasing probability order and cut it off once it reaches a particular probability specified by `top_p`. You should either alter `temperature` or `top_p`, but not both.
    ///
    ///Recommended for advanced use cases only. You usually only need to use `temperature`.
    #[validate(range(min = 0.0, max = 1.0))]
    pub top_p: Option<f64>,
}
///System prompt.
///
///A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.claude.com/en/docs/system-prompts).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum CreateMessageParamsSystem {
    #[default]
    String(String),
    Array(Vec<RequestTextBlock>),
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct CreateMessageParamsWithoutStream {
    ///The maximum number of tokens to generate before stopping.
    ///
    ///Note that our models may stop _before_ reaching this maximum. This parameter only specifies the absolute maximum number of tokens to generate.
    ///
    ///Different models have different maximum values for this parameter.  See [models](https://docs.claude.com/en/docs/models-overview) for details.
    #[validate(range(min = 1i64))]
    pub max_tokens: i64,
    ///Input messages.
    ///
    ///Our models are trained to operate on alternating `user` and `assistant` conversational turns. When creating a new `Message`, you specify the prior conversational turns with the `messages` parameter, and the model then generates the next `Message` in the conversation. Consecutive `user` or `assistant` turns in your request will be combined into a single turn.
    ///
    ///Each input message must be an object with a `role` and `content`. You can specify a single `user`-role message, or you can include multiple `user` and `assistant` messages.
    ///
    ///If the final message uses the `assistant` role, the response content will continue immediately from the content in that message. This can be used to constrain part of the model's response.
    ///
    ///Example with a single `user` message:
    ///
    ///```json
    ///[{"role": "user", "content": "Hello, Claude"}]
    ///```
    ///
    ///Example with multiple conversational turns:
    ///
    ///```json
    ///[
    ///  {"role": "user", "content": "Hello there."},
    ///  {"role": "assistant", "content": "Hi, I'm Claude. How can I help you?"},
    ///  {"role": "user", "content": "Can you explain LLMs in plain English?"},
    ///]
    ///```
    ///
    ///Example with a partially-filled response from Claude:
    ///
    ///```json
    ///[
    ///  {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
    ///  {"role": "assistant", "content": "The best answer is ("},
    ///]
    ///```
    ///
    ///Each input message `content` may be either a single `string` or an array of content blocks, where each block has a specific `type`. Using a `string` for `content` is shorthand for an array of one content block of type `"text"`. The following input messages are equivalent:
    ///
    ///```json
    ///{"role": "user", "content": "Hello, Claude"}
    ///```
    ///
    ///```json
    ///{"role": "user", "content": [{"type": "text", "text": "Hello, Claude"}]}
    ///```
    ///
    ///See [input examples](https://docs.claude.com/en/api/messages-examples).
    ///
    ///Note that if you want to include a [system prompt](https://docs.claude.com/en/docs/system-prompts), you can use the top-level `system` parameter  there is no `"system"` role for input messages in the Messages API.
    ///
    ///There is a limit of 100,000 messages in a single request.
    pub messages: Vec<InputMessage>,
    pub metadata: Option<Metadata>,
    ///The model that will complete your prompt.
    ///
    ///See [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
    pub model: Model,
    ///Determines whether to use priority capacity (if available) or standard capacity for this request.
    ///
    ///Anthropic offers different levels of service for your API requests. See [service-tiers](https://docs.claude.com/en/api/service-tiers) for details.
    pub service_tier: Option<ServiceTier>,
    ///Custom text sequences that will cause the model to stop generating.
    ///
    ///Our models will normally stop when they have naturally completed their turn, which will result in a response `stop_reason` of `"end_turn"`.
    ///
    ///If you want the model to stop generating when it encounters custom strings of text, you can use the `stop_sequences` parameter. If the model encounters one of the custom sequences, the response `stop_reason` value will be `"stop_sequence"` and the response `stop_sequence` value will contain the matched stop sequence.
    pub stop_sequences: Option<Vec<String>>,
    ///System prompt.
    ///
    ///A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.claude.com/en/docs/system-prompts).
    pub system: Option<System>,
    ///Amount of randomness injected into the response.
    ///
    ///Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0` for analytical / multiple choice, and closer to `1.0` for creative and generative tasks.
    ///
    ///Note that even with `temperature` of `0.0`, the results will not be fully deterministic.
    #[validate(range(min = 0.0, max = 1.0))]
    pub temperature: Option<f64>,
    ///Configuration for enabling Claude's extended thinking.
    ///
    ///When enabled, responses include `thinking` content blocks showing Claude's thinking process before the final answer. Requires a minimum budget of 1,024 tokens and counts towards your `max_tokens` limit.
    ///
    ///See [extended thinking](https://docs.claude.com/en/docs/build-with-claude/extended-thinking) for details.
    pub thinking: Option<Box<ThinkingConfigParam>>,
    ///How the model should use the provided tools. The model can use a specific tool, any available tool, decide by itself, or not use tools at all.
    pub tool_choice: Option<Box<ToolChoice>>,
    ///Definitions of tools that the model may use.
    ///
    ///If you include `tools` in your API request, the model may return `tool_use` content blocks that represent the model's use of those tools. You can then run those tools using the tool input generated by the model and then optionally return results back to the model using `tool_result` content blocks.
    ///
    ///There are two types of tools: **client tools** and **server tools**. The behavior described below applies to client tools. For [server tools](https://docs.claude.com/en/docs/agents-and-tools/tool-use/overview\#server-tools), see their individual documentation as each has its own behavior (e.g., the [web search tool](https://docs.claude.com/en/docs/agents-and-tools/tool-use/web-search-tool)).
    ///
    ///Each tool definition includes:
    ///
    ///* `name`: Name of the tool.
    ///* `description`: Optional, but strongly-recommended description of the tool.
    ///* `input_schema`: [JSON schema](https://json-schema.org/draft/2020-12) for the tool `input` shape that the model will produce in `tool_use` output content blocks.
    ///
    ///For example, if you defined `tools` as:
    ///
    ///```json
    ///[
    ///  {
    ///    "name": "get_stock_price",
    ///    "description": "Get the current stock price for a given ticker symbol.",
    ///    "input_schema": {
    ///      "type": "object",
    ///      "properties": {
    ///        "ticker": {
    ///          "type": "string",
    ///          "description": "The stock ticker symbol, e.g. AAPL for Apple Inc."
    ///        }
    ///      },
    ///      "required": ["ticker"]
    ///    }
    ///  }
    ///]
    ///```
    ///
    ///And then asked the model "What's the S&P 500 at today?", the model might produce `tool_use` content blocks in the response like this:
    ///
    ///```json
    ///[
    ///  {
    ///    "type": "tool_use",
    ///    "id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
    ///    "name": "get_stock_price",
    ///    "input": { "ticker": "^GSPC" }
    ///  }
    ///]
    ///```
    ///
    ///You might then run your `get_stock_price` tool with `{"ticker": "^GSPC"}` as an input, and return the following back to the model in a subsequent `user` message:
    ///
    ///```json
    ///[
    ///  {
    ///    "type": "tool_result",
    ///    "tool_use_id": "toolu_01D7FLrfh4GYq7yT1ULFeyMV",
    ///    "content": "259.75 USD"
    ///  }
    ///]
    ///```
    ///
    ///Tools can be used for workflows that include running client-side tools and functions, or more generally whenever you want the model to produce a particular JSON structure of output.
    ///
    ///See our [guide](https://docs.claude.com/en/docs/tool-use) for more details.
    pub tools: Option<Vec<ToolKind>>,
    ///Only sample from the top K options for each subsequent token.
    ///
    ///Used to remove "long tail" low probability responses. [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).
    ///
    ///Recommended for advanced use cases only. You usually only need to use `temperature`.
    #[validate(range(min = 0i64))]
    pub top_k: Option<i64>,
    ///Use nucleus sampling.
    ///
    ///In nucleus sampling, we compute the cumulative distribution over all the options for each subsequent token in decreasing probability order and cut it off once it reaches a particular probability specified by `top_p`. You should either alter `temperature` or `top_p`, but not both.
    ///
    ///Recommended for advanced use cases only. You usually only need to use `temperature`.
    #[validate(range(min = 0.0, max = 1.0))]
    pub top_p: Option<f64>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct CreateSkillResponse {
    ///ISO 8601 timestamp of when the skill was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Display title for the skill.
    ///
    ///This is a human-readable label that is not included in the prompt sent to the model.
    pub display_title: Option<String>,
    ///Unique identifier for the skill.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///The latest version identifier for the skill.
    ///
    ///This represents the most recent version of the skill that has been created.
    pub latest_version: Option<String>,
    ///Source of the skill.
    ///
    ///This may be one of the following values:
    ///* `"custom"`: the skill was created by a user
    ///* `"anthropic"`: the skill was created by Anthropic
    #[validate(length(min = 1u64))]
    pub source: String,
    ///Object type.
    ///
    ///For Skills, this is always `"skill"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill".to_string()))]
    pub r#type: Option<String>,
    ///ISO 8601 timestamp of when the skill was last updated.
    #[validate(length(min = 1u64))]
    pub updated_at: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct CreateSkillVersionResponse {
    ///ISO 8601 timestamp of when the skill version was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Description of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub description: String,
    ///Directory name of the skill version.
    ///
    ///This is the top-level directory name that was extracted from the uploaded files.
    #[validate(length(min = 1u64))]
    pub directory: String,
    ///Unique identifier for the skill version.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Human-readable name of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub name: String,
    ///Identifier for the skill that this version belongs to.
    #[validate(length(min = 1u64))]
    pub skill_id: String,
    ///Object type.
    ///
    ///For Skill Versions, this is always `"skill_version"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill_version".to_string()))]
    pub r#type: Option<String>,
    ///Version identifier for the skill.
    ///
    ///Each version is identified by a Unix epoch timestamp (e.g., "1759178010641129").
    #[validate(length(min = 1u64))]
    pub version: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct DeleteMessageBatchResponse {
    ///ID of the Message Batch.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Deleted object type.
    ///
    ///For Message Batches, this is always `"message_batch_deleted"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("message_batch_deleted".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct DeleteSkillResponse {
    ///Unique identifier for the skill.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Deleted object type.
    ///
    ///For Skills, this is always `"skill_deleted"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill_deleted".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct DeleteSkillVersionResponse {
    ///Version identifier for the skill.
    ///
    ///Each version is identified by a Unix epoch timestamp (e.g., "1759178010641129").
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Deleted object type.
    ///
    ///For Skill Versions, this is always `"skill_version_deleted"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill_version_deleted".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ErrorResponse {
    pub error: ErrorResponseError,
    pub request_id: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum ErrorResponseError {
    API(APIError),
    Authentication(AuthenticationError),
    Billing(BillingError),
    GatewayTimeout(GatewayTimeoutError),
    InvalidRequest(InvalidRequestError),
    NotFound(NotFoundError),
    Overloaded(OverloadedError),
    Permission(PermissionError),
    RateLimit(RateLimitError),
}
impl ErrorResponseError {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for ErrorResponseError {
    fn default() -> Self {
        Self::API(<APIError>::default())
    }
}
impl serde::Serialize for ErrorResponseError {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::API(v) => v.serialize(serializer),
            Self::Authentication(v) => v.serialize(serializer),
            Self::Billing(v) => v.serialize(serializer),
            Self::GatewayTimeout(v) => v.serialize(serializer),
            Self::InvalidRequest(v) => v.serialize(serializer),
            Self::NotFound(v) => v.serialize(serializer),
            Self::Overloaded(v) => v.serialize(serializer),
            Self::Permission(v) => v.serialize(serializer),
            Self::RateLimit(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for ErrorResponseError {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("api_error") => serde_json::from_value(value)
                .map(Self::API)
                .map_err(serde::de::Error::custom),
            Some("authentication_error") => serde_json::from_value(value)
                .map(Self::Authentication)
                .map_err(serde::de::Error::custom),
            Some("billing_error") => serde_json::from_value(value)
                .map(Self::Billing)
                .map_err(serde::de::Error::custom),
            Some("timeout_error") => serde_json::from_value(value)
                .map(Self::GatewayTimeout)
                .map_err(serde::de::Error::custom),
            Some("invalid_request_error") => serde_json::from_value(value)
                .map(Self::InvalidRequest)
                .map_err(serde::de::Error::custom),
            Some("not_found_error") => serde_json::from_value(value)
                .map(Self::NotFound)
                .map_err(serde::de::Error::custom),
            Some("overloaded_error") => serde_json::from_value(value)
                .map(Self::Overloaded)
                .map_err(serde::de::Error::custom),
            Some("permission_error") => serde_json::from_value(value)
                .map(Self::Permission)
                .map_err(serde::de::Error::custom),
            Some("rate_limit_error") => serde_json::from_value(value)
                .map(Self::RateLimit)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl ErrorResponseError {
    pub fn invalid_request() -> Self {
        Self::InvalidRequest(InvalidRequestError::default())
    }
    pub fn authentication() -> Self {
        Self::Authentication(AuthenticationError::default())
    }
    pub fn billing() -> Self {
        Self::Billing(BillingError::default())
    }
    pub fn permission() -> Self {
        Self::Permission(PermissionError::default())
    }
    pub fn not_found() -> Self {
        Self::NotFound(NotFoundError::default())
    }
    pub fn rate_limit() -> Self {
        Self::RateLimit(RateLimitError::default())
    }
    pub fn gateway_timeout() -> Self {
        Self::GatewayTimeout(GatewayTimeoutError::default())
    }
    pub fn api() -> Self {
        Self::API(APIError::default())
    }
    pub fn overloaded() -> Self {
        Self::Overloaded(OverloadedError::default())
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ErroredResult {
    #[validate(nested)]
    pub error: ErrorResponse,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("errored".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ExpiredResult {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("expired".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct FileDeleteResponse {
    ///ID of the deleted file.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Deleted object type.
    ///
    ///For file deletion, this is always `"file_deleted"`.
    #[serde(rename = "type")]
    #[default(Some("file_deleted".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct FileListResponse {
    ///List of file metadata objects.
    #[validate(nested)]
    pub data: Vec<FileMetadataSchema>,
    ///ID of the first file in this page of results.
    pub first_id: Option<String>,
    ///Whether there are more results available.
    #[default(Some(false))]
    pub has_more: Option<bool>,
    ///ID of the last file in this page of results.
    pub last_id: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct FileMetadataSchema {
    ///RFC 3339 datetime string representing when the file was created.
    pub created_at: chrono::DateTime<chrono::Utc>,
    ///Whether the file can be downloaded.
    #[default(Some(false))]
    pub downloadable: Option<bool>,
    ///Original filename of the uploaded file.
    #[validate(length(min = 1u64, max = 500u64))]
    pub filename: String,
    ///Unique object identifier.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///MIME type of the file.
    #[validate(length(min = 1u64, max = 255u64))]
    pub mime_type: String,
    ///Size of the file in bytes.
    #[validate(range(min = 0i64))]
    pub size_bytes: i64,
    ///Object type.
    ///
    ///For files, this is always `"file"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("file".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct GatewayTimeoutError {
    #[validate(length(min = 1u64))]
    #[default(Some("Request timeout".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("timeout_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct GetSkillResponse {
    ///ISO 8601 timestamp of when the skill was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Display title for the skill.
    ///
    ///This is a human-readable label that is not included in the prompt sent to the model.
    pub display_title: Option<String>,
    ///Unique identifier for the skill.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///The latest version identifier for the skill.
    ///
    ///This represents the most recent version of the skill that has been created.
    pub latest_version: Option<String>,
    ///Source of the skill.
    ///
    ///This may be one of the following values:
    ///* `"custom"`: the skill was created by a user
    ///* `"anthropic"`: the skill was created by Anthropic
    #[validate(length(min = 1u64))]
    pub source: String,
    ///Object type.
    ///
    ///For Skills, this is always `"skill"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill".to_string()))]
    pub r#type: Option<String>,
    ///ISO 8601 timestamp of when the skill was last updated.
    #[validate(length(min = 1u64))]
    pub updated_at: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct GetSkillVersionResponse {
    ///ISO 8601 timestamp of when the skill version was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Description of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub description: String,
    ///Directory name of the skill version.
    ///
    ///This is the top-level directory name that was extracted from the uploaded files.
    #[validate(length(min = 1u64))]
    pub directory: String,
    ///Unique identifier for the skill version.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Human-readable name of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub name: String,
    ///Identifier for the skill that this version belongs to.
    #[validate(length(min = 1u64))]
    pub skill_id: String,
    ///Object type.
    ///
    ///For Skill Versions, this is always `"skill_version"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill_version".to_string()))]
    pub r#type: Option<String>,
    ///Version identifier for the skill.
    ///
    ///Each version is identified by a Unix epoch timestamp (e.g., "1759178010641129").
    #[validate(length(min = 1u64))]
    pub version: String,
}
#[derive(Debug, Clone, PartialEq)]
pub enum InputContentBlock {
    Document(RequestDocumentBlock),
    Image(RequestImageBlock),
    RedactedThinking(RequestRedactedThinkingBlock),
    SearchResult(RequestSearchResultBlock),
    ServerToolUse(RequestServerToolUseBlock),
    Text(RequestTextBlock),
    Thinking(RequestThinkingBlock),
    ToolResult(RequestToolResultBlock),
    ToolUse(RequestToolUseBlock),
    WebSearchToolResult(RequestWebSearchToolResultBlock),
}
impl InputContentBlock {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for InputContentBlock {
    fn default() -> Self {
        Self::Document(<RequestDocumentBlock>::default())
    }
}
impl serde::Serialize for InputContentBlock {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Document(v) => v.serialize(serializer),
            Self::Image(v) => v.serialize(serializer),
            Self::RedactedThinking(v) => v.serialize(serializer),
            Self::SearchResult(v) => v.serialize(serializer),
            Self::ServerToolUse(v) => v.serialize(serializer),
            Self::Text(v) => v.serialize(serializer),
            Self::Thinking(v) => v.serialize(serializer),
            Self::ToolResult(v) => v.serialize(serializer),
            Self::ToolUse(v) => v.serialize(serializer),
            Self::WebSearchToolResult(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for InputContentBlock {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("document") => serde_json::from_value(value)
                .map(Self::Document)
                .map_err(serde::de::Error::custom),
            Some("image") => serde_json::from_value(value)
                .map(Self::Image)
                .map_err(serde::de::Error::custom),
            Some("redacted_thinking") => serde_json::from_value(value)
                .map(Self::RedactedThinking)
                .map_err(serde::de::Error::custom),
            Some("search_result") => serde_json::from_value(value)
                .map(Self::SearchResult)
                .map_err(serde::de::Error::custom),
            Some("server_tool_use") => serde_json::from_value(value)
                .map(Self::ServerToolUse)
                .map_err(serde::de::Error::custom),
            Some("text") => serde_json::from_value(value)
                .map(Self::Text)
                .map_err(serde::de::Error::custom),
            Some("thinking") => serde_json::from_value(value)
                .map(Self::Thinking)
                .map_err(serde::de::Error::custom),
            Some("tool_result") => serde_json::from_value(value)
                .map(Self::ToolResult)
                .map_err(serde::de::Error::custom),
            Some("tool_use") => serde_json::from_value(value)
                .map(Self::ToolUse)
                .map_err(serde::de::Error::custom),
            Some("web_search_tool_result") => serde_json::from_value(value)
                .map(Self::WebSearchToolResult)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl InputContentBlock {
    pub fn text(text: String) -> Self {
        Self::Text(RequestTextBlock {
            text,
            ..Default::default()
        })
    }
    pub fn image(source: RequestImageBlockSource) -> Self {
        Self::Image(RequestImageBlock {
            source,
            ..Default::default()
        })
    }
    pub fn document(source: RequestDocumentBlockSource) -> Self {
        Self::Document(RequestDocumentBlock {
            source,
            ..Default::default()
        })
    }
    pub fn redacted_thinking(data: String) -> Self {
        Self::RedactedThinking(RequestRedactedThinkingBlock {
            data,
            ..Default::default()
        })
    }
    pub fn tool_result(tool_use_id: String) -> Self {
        Self::ToolResult(RequestToolResultBlock {
            tool_use_id,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct InputJsonContentBlockDelta {
    #[validate(length(min = 1u64))]
    pub partial_json: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("input_json_delta".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields)]
pub struct InputMessage {
    pub content: InputMessageContent,
    pub role: InputMessageRole,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum InputMessageContent {
    #[default]
    String(String),
    Array(Vec<InputContentBlock>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum InputMessageRole {
    #[serde(rename = "user")]
    #[default]
    User,
    #[serde(rename = "assistant")]
    Assistant,
}
impl core::fmt::Display for InputMessageRole {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::User => write!(f, "user"),
            Self::Assistant => write!(f, "assistant"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct InputSchema {
    pub properties: Option<std::collections::HashMap<String, serde_json::Value>>,
    pub required: Option<Vec<String>>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("object".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct InvalidRequestError {
    #[validate(length(min = 1u64))]
    #[default(Some("Invalid request".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("invalid_request_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct ListResponseMessageBatch {
    #[validate(nested)]
    pub data: Vec<MessageBatch>,
    ///First ID in the `data` list. Can be used as the `before_id` for the previous page.
    pub first_id: Option<String>,
    ///Indicates if there are more results in the requested page direction.
    pub has_more: bool,
    ///Last ID in the `data` list. Can be used as the `after_id` for the next page.
    pub last_id: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct ListResponseModelInfo {
    #[validate(nested)]
    pub data: Vec<ModelInfo>,
    ///First ID in the `data` list. Can be used as the `before_id` for the previous page.
    pub first_id: Option<String>,
    ///Indicates if there are more results in the requested page direction.
    pub has_more: bool,
    ///Last ID in the `data` list. Can be used as the `after_id` for the next page.
    pub last_id: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct ListSkillVersionsResponse {
    ///List of skill versions.
    #[validate(nested)]
    pub data: Vec<SkillVersion>,
    ///Indicates if there are more results in the requested page direction.
    pub has_more: bool,
    ///Token to provide in as `page` in the subsequent request to retrieve the next page of data.
    pub next_page: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct ListSkillsResponse {
    ///List of skills.
    #[validate(nested)]
    pub data: Vec<Skill>,
    ///Whether there are more results available.
    ///
    ///If `true`, there are additional results that can be fetched using the `next_page` token.
    pub has_more: bool,
    ///Token for fetching the next page of results.
    ///
    ///If `null`, there are no more results available. Pass this value to the `page_token` parameter in the next request to get the next page.
    pub next_page: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct Message {
    ///Content generated by the model.
    ///
    ///This is an array of content blocks, each of which has a `type` that determines its shape.
    ///
    ///Example:
    ///
    ///```json
    ///[{"type": "text", "text": "Hi, I'm Claude."}]
    ///```
    ///
    ///If the request input `messages` ended with an `assistant` turn, then the response `content` will continue directly from that last turn. You can use this to constrain the model's output.
    ///
    ///For example, if the input `messages` were:
    ///```json
    ///[
    ///  {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
    ///  {"role": "assistant", "content": "The best answer is ("}
    ///]
    ///```
    ///
    ///Then the response `content` might be:
    ///
    ///```json
    ///[{"type": "text", "text": "B)"}]
    ///```
    pub content: Vec<ContentBlock>,
    ///Unique object identifier.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///The model that will complete your prompt.
    ///
    ///See [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
    pub model: Model,
    ///Conversational role of the generated message.
    ///
    ///This will always be `"assistant"`.
    #[validate(length(min = 1u64))]
    #[default(Some("assistant".to_string()))]
    pub role: Option<String>,
    ///The reason that we stopped.
    ///
    ///This may be one the following values:
    ///* `"end_turn"`: the model reached a natural stopping point
    ///* `"max_tokens"`: we exceeded the requested `max_tokens` or the model's maximum
    ///* `"stop_sequence"`: one of your provided custom `stop_sequences` was generated
    ///* `"tool_use"`: the model invoked one or more tools
    ///* `"pause_turn"`: we paused a long-running turn. You may provide the response back as-is in a subsequent request to let the model continue.
    ///* `"refusal"`: when streaming classifiers intervene to handle potential policy violations
    ///
    ///In non-streaming mode this value is always non-null. In streaming mode, it is null in the `message_start` event and non-null otherwise.
    pub stop_reason: Option<StopReason>,
    ///Which custom stop sequence was generated, if any.
    ///
    ///This value will be a non-null string if one of your custom stop sequences was generated.
    pub stop_sequence: Option<String>,
    ///Object type.
    ///
    ///For Messages, this is always `"message"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("message".to_string()))]
    pub r#type: Option<String>,
    #[validate(nested)]
    pub usage: Usage,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct MessageBatch {
    ///RFC 3339 datetime string representing the time at which the Message Batch was archived and its results became unavailable.
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    ///RFC 3339 datetime string representing the time at which cancellation was initiated for the Message Batch. Specified only if cancellation was initiated.
    pub cancel_initiated_at: Option<chrono::DateTime<chrono::Utc>>,
    ///RFC 3339 datetime string representing the time at which the Message Batch was created.
    pub created_at: chrono::DateTime<chrono::Utc>,
    ///RFC 3339 datetime string representing the time at which processing for the Message Batch ended. Specified only once processing ends.
    ///
    ///Processing ends when every request in a Message Batch has either succeeded, errored, canceled, or expired.
    pub ended_at: Option<chrono::DateTime<chrono::Utc>>,
    ///RFC 3339 datetime string representing the time at which the Message Batch will expire and end processing, which is 24 hours after creation.
    pub expires_at: chrono::DateTime<chrono::Utc>,
    ///Unique object identifier.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Processing status of the Message Batch.
    pub processing_status: MessageBatchProcessingStatus,
    pub request_counts: RequestCounts,
    ///URL to a `.jsonl` file containing the results of the Message Batch requests. Specified only once processing ends.
    ///
    ///Results in the file are not guaranteed to be in the same order as requests. Use the `custom_id` field to match results to requests.
    pub results_url: Option<String>,
    ///Object type.
    ///
    ///For Message Batches, this is always `"message_batch"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("message_batch".to_string()))]
    pub r#type: Option<String>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct MessageBatchIndividualRequestParams {
    ///Developer-provided ID created for each request in a Message Batch. Useful for matching results to requests, as results may be given out of request order.
    ///
    ///Must be unique for each request within the Message Batch.
    #[validate(
        length(min = 1u64, max = 64u64),
        regex(path = "REGEX_BETA_MESSAGE_BATCH_INDIVIDUAL_REQUEST_PARAMS_CUSTOM_ID")
    )]
    pub custom_id: String,
    #[validate(nested)]
    pub params: CreateMessageParams,
}
///This is a single line in the response `.jsonl` file and does not represent the response as a whole.
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct MessageBatchIndividualResponse {
    ///Developer-provided ID created for each request in a Message Batch. Useful for matching results to requests, as results may be given out of request order.
    ///
    ///Must be unique for each request within the Message Batch.
    #[validate(length(min = 1u64))]
    pub custom_id: String,
    ///Processing result for this request.
    ///
    ///Contains a Message output if processing was successful, an error response if processing failed, or the reason why processing was not attempted, such as cancellation or expiration.
    pub result: MessageBatchIndividualResponseResult,
}
///Processing result for this request.
///
///Contains a Message output if processing was successful, an error response if processing failed, or the reason why processing was not attempted, such as cancellation or expiration.
#[derive(Debug, Clone, PartialEq)]
pub enum MessageBatchIndividualResponseResult {
    Canceled(CanceledResult),
    Errored(ErroredResult),
    Expired(ExpiredResult),
    Succeeded(SucceededResult),
}
impl MessageBatchIndividualResponseResult {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for MessageBatchIndividualResponseResult {
    fn default() -> Self {
        Self::Canceled(<CanceledResult>::default())
    }
}
impl serde::Serialize for MessageBatchIndividualResponseResult {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Canceled(v) => v.serialize(serializer),
            Self::Errored(v) => v.serialize(serializer),
            Self::Expired(v) => v.serialize(serializer),
            Self::Succeeded(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for MessageBatchIndividualResponseResult {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("canceled") => serde_json::from_value(value)
                .map(Self::Canceled)
                .map_err(serde::de::Error::custom),
            Some("errored") => serde_json::from_value(value)
                .map(Self::Errored)
                .map_err(serde::de::Error::custom),
            Some("expired") => serde_json::from_value(value)
                .map(Self::Expired)
                .map_err(serde::de::Error::custom),
            Some("succeeded") => serde_json::from_value(value)
                .map(Self::Succeeded)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl MessageBatchIndividualResponseResult {
    pub fn succeeded(message: Message) -> Self {
        Self::Succeeded(SucceededResult {
            message,
            ..Default::default()
        })
    }
    pub fn errored(error: ErrorResponse) -> Self {
        Self::Errored(ErroredResult {
            error,
            ..Default::default()
        })
    }
    pub fn canceled(r#type: Option<String>) -> Self {
        Self::Canceled(CanceledResult {
            r#type,
            ..Default::default()
        })
    }
    pub fn expired(r#type: Option<String>) -> Self {
        Self::Expired(ExpiredResult {
            r#type,
            ..Default::default()
        })
    }
}
///Processing status of the Message Batch.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum MessageBatchProcessingStatus {
    #[serde(rename = "in_progress")]
    #[default]
    InProgress,
    #[serde(rename = "canceling")]
    Canceling,
    #[serde(rename = "ended")]
    Ended,
}
impl core::fmt::Display for MessageBatchProcessingStatus {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::InProgress => write!(f, "in_progress"),
            Self::Canceling => write!(f, "canceling"),
            Self::Ended => write!(f, "ended"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub struct MessageDelta {
    pub stop_reason: Option<StopReason>,
    pub stop_sequence: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct MessageDeltaEvent {
    pub delta: MessageDelta,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("message_delta".to_string()))]
    pub r#type: Option<String>,
    #[validate(nested)]
    pub usage: MessageDeltaUsage,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct MessageDeltaUsage {
    ///The cumulative number of input tokens used to create the cache entry.
    pub cache_creation_input_tokens: Option<i64>,
    ///The cumulative number of input tokens read from the cache.
    pub cache_read_input_tokens: Option<i64>,
    ///The cumulative number of input tokens which were used.
    pub input_tokens: Option<i64>,
    ///The cumulative number of output tokens which were used.
    pub output_tokens: i64,
    ///The number of server tool requests.
    #[validate(nested)]
    pub server_tool_use: Option<ServerToolUsage>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct MessageStartEvent {
    #[validate(nested)]
    pub message: Message,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("message_start".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct MessageStopEvent {
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("message_stop".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum MessageStreamEvent {
    ContentBlockDelta(ContentBlockDeltaEvent),
    ContentBlockStart(ContentBlockStartEvent),
    ContentBlockStop(ContentBlockStopEvent),
    MessageDelta(MessageDeltaEvent),
    MessageStart(MessageStartEvent),
    MessageStop(MessageStopEvent),
}
impl MessageStreamEvent {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for MessageStreamEvent {
    fn default() -> Self {
        Self::ContentBlockDelta(<ContentBlockDeltaEvent>::default())
    }
}
impl serde::Serialize for MessageStreamEvent {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::ContentBlockDelta(v) => v.serialize(serializer),
            Self::ContentBlockStart(v) => v.serialize(serializer),
            Self::ContentBlockStop(v) => v.serialize(serializer),
            Self::MessageDelta(v) => v.serialize(serializer),
            Self::MessageStart(v) => v.serialize(serializer),
            Self::MessageStop(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for MessageStreamEvent {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("content_block_delta") => serde_json::from_value(value)
                .map(Self::ContentBlockDelta)
                .map_err(serde::de::Error::custom),
            Some("content_block_start") => serde_json::from_value(value)
                .map(Self::ContentBlockStart)
                .map_err(serde::de::Error::custom),
            Some("content_block_stop") => serde_json::from_value(value)
                .map(Self::ContentBlockStop)
                .map_err(serde::de::Error::custom),
            Some("message_delta") => serde_json::from_value(value)
                .map(Self::MessageDelta)
                .map_err(serde::de::Error::custom),
            Some("message_start") => serde_json::from_value(value)
                .map(Self::MessageStart)
                .map_err(serde::de::Error::custom),
            Some("message_stop") => serde_json::from_value(value)
                .map(Self::MessageStop)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl MessageStreamEvent {
    pub fn start(message: Message) -> Self {
        Self::MessageStart(MessageStartEvent {
            message,
            ..Default::default()
        })
    }
    pub fn stop() -> Self {
        Self::MessageStop(MessageStopEvent::default())
    }
    pub fn content_block_stop(index: i64) -> Self {
        Self::ContentBlockStop(ContentBlockStopEvent {
            index,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields)]
pub struct Metadata {
    ///An external identifier for the user who is associated with the request.
    ///
    ///This should be a uuid, hash value, or other opaque identifier. Anthropic may use this id to help detect abuse. Do not include any identifying information such as name, email address, or phone number.
    pub user_id: Option<String>,
}
///The model that will complete your prompt.
///
///See [models](https://docs.anthropic.com/en/docs/models-overview) for additional details and options.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum Model {
    #[default]
    Known(ModelKnown),
    Other(String),
}
impl Model {
    ///Premium model combining maximum intelligence with practical performance
    pub fn claude_opus4520251101() -> Self {
        Self::Known(ModelKnown::ClaudeOpus4520251101)
    }
    ///Premium model combining maximum intelligence with practical performance
    pub fn claude_opus45() -> Self {
        Self::Known(ModelKnown::ClaudeOpus45)
    }
    ///High-performance model with early extended thinking
    pub fn claude37_sonnet_latest() -> Self {
        Self::Known(ModelKnown::Claude37SonnetLatest)
    }
    ///High-performance model with early extended thinking
    pub fn claude37_sonnet20250219() -> Self {
        Self::Known(ModelKnown::Claude37Sonnet20250219)
    }
    ///Fastest and most compact model for near-instant responsiveness
    pub fn claude35_haiku_latest() -> Self {
        Self::Known(ModelKnown::Claude35HaikuLatest)
    }
    ///Our fastest model
    pub fn claude35_haiku20241022() -> Self {
        Self::Known(ModelKnown::Claude35Haiku20241022)
    }
    ///Hybrid model, capable of near-instant responses and extended thinking
    pub fn claude_haiku45() -> Self {
        Self::Known(ModelKnown::ClaudeHaiku45)
    }
    ///Hybrid model, capable of near-instant responses and extended thinking
    pub fn claude_haiku4520251001() -> Self {
        Self::Known(ModelKnown::ClaudeHaiku4520251001)
    }
    ///High-performance model with extended thinking
    pub fn claude_sonnet420250514() -> Self {
        Self::Known(ModelKnown::ClaudeSonnet420250514)
    }
    ///High-performance model with extended thinking
    pub fn claude_sonnet40() -> Self {
        Self::Known(ModelKnown::ClaudeSonnet40)
    }
    ///High-performance model with extended thinking
    pub fn claude4_sonnet20250514() -> Self {
        Self::Known(ModelKnown::Claude4Sonnet20250514)
    }
    ///Our best model for real-world agents and coding
    pub fn claude_sonnet45() -> Self {
        Self::Known(ModelKnown::ClaudeSonnet45)
    }
    ///Our best model for real-world agents and coding
    pub fn claude_sonnet4520250929() -> Self {
        Self::Known(ModelKnown::ClaudeSonnet4520250929)
    }
    ///Our most capable model
    pub fn claude_opus40() -> Self {
        Self::Known(ModelKnown::ClaudeOpus40)
    }
    ///Our most capable model
    pub fn claude_opus420250514() -> Self {
        Self::Known(ModelKnown::ClaudeOpus420250514)
    }
    ///Our most capable model
    pub fn claude4_opus20250514() -> Self {
        Self::Known(ModelKnown::Claude4Opus20250514)
    }
    ///Our most capable model
    pub fn claude_opus4120250805() -> Self {
        Self::Known(ModelKnown::ClaudeOpus4120250805)
    }
    ///Excels at writing and complex tasks
    pub fn claude3_opus_latest() -> Self {
        Self::Known(ModelKnown::Claude3OpusLatest)
    }
    ///Excels at writing and complex tasks
    pub fn claude3_opus20240229() -> Self {
        Self::Known(ModelKnown::Claude3Opus20240229)
    }
    ///Our previous most fast and cost-effective
    pub fn claude3_haiku20240307() -> Self {
        Self::Known(ModelKnown::Claude3Haiku20240307)
    }
}
impl core::fmt::Display for Model {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Known(v) => write!(f, "{v}"),
            Self::Other(v) => write!(f, "{v}"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ModelInfo {
    ///RFC 3339 datetime string representing the time at which the model was released. May be set to an epoch value if the release date is unknown.
    pub created_at: chrono::DateTime<chrono::Utc>,
    ///A human-readable name for the model.
    #[validate(length(min = 1u64))]
    pub display_name: String,
    ///Unique model identifier.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Object type.
    ///
    ///For Models, this is always `"model"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("model".to_string()))]
    pub r#type: Option<String>,
}
///Known values for the string enum.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum ModelKnown {
    ///Premium model combining maximum intelligence with practical performance
    #[serde(rename = "claude-opus-4-5-20251101")]
    #[default]
    ClaudeOpus4520251101,
    ///Premium model combining maximum intelligence with practical performance
    #[serde(rename = "claude-opus-4-5")]
    ClaudeOpus45,
    ///High-performance model with early extended thinking
    #[deprecated]
    #[serde(rename = "claude-3-7-sonnet-latest")]
    Claude37SonnetLatest,
    ///High-performance model with early extended thinking
    #[deprecated]
    #[serde(rename = "claude-3-7-sonnet-20250219")]
    Claude37Sonnet20250219,
    ///Fastest and most compact model for near-instant responsiveness
    #[deprecated]
    #[serde(rename = "claude-3-5-haiku-latest")]
    Claude35HaikuLatest,
    ///Our fastest model
    #[deprecated]
    #[serde(rename = "claude-3-5-haiku-20241022")]
    Claude35Haiku20241022,
    ///Hybrid model, capable of near-instant responses and extended thinking
    #[serde(rename = "claude-haiku-4-5")]
    ClaudeHaiku45,
    ///Hybrid model, capable of near-instant responses and extended thinking
    #[serde(rename = "claude-haiku-4-5-20251001")]
    ClaudeHaiku4520251001,
    ///High-performance model with extended thinking
    #[serde(rename = "claude-sonnet-4-20250514")]
    ClaudeSonnet420250514,
    ///High-performance model with extended thinking
    #[serde(rename = "claude-sonnet-4-0")]
    ClaudeSonnet40,
    ///High-performance model with extended thinking
    #[serde(rename = "claude-4-sonnet-20250514")]
    Claude4Sonnet20250514,
    ///Our best model for real-world agents and coding
    #[serde(rename = "claude-sonnet-4-5")]
    ClaudeSonnet45,
    ///Our best model for real-world agents and coding
    #[serde(rename = "claude-sonnet-4-5-20250929")]
    ClaudeSonnet4520250929,
    ///Our most capable model
    #[serde(rename = "claude-opus-4-0")]
    ClaudeOpus40,
    ///Our most capable model
    #[serde(rename = "claude-opus-4-20250514")]
    ClaudeOpus420250514,
    ///Our most capable model
    #[serde(rename = "claude-4-opus-20250514")]
    Claude4Opus20250514,
    ///Our most capable model
    #[serde(rename = "claude-opus-4-1-20250805")]
    ClaudeOpus4120250805,
    ///Excels at writing and complex tasks
    #[deprecated]
    #[serde(rename = "claude-3-opus-latest")]
    Claude3OpusLatest,
    ///Excels at writing and complex tasks
    #[deprecated]
    #[serde(rename = "claude-3-opus-20240229")]
    Claude3Opus20240229,
    ///Our previous most fast and cost-effective
    #[serde(rename = "claude-3-haiku-20240307")]
    Claude3Haiku20240307,
}
impl core::fmt::Display for ModelKnown {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ClaudeOpus4520251101 => write!(f, "claude-opus-4-5-20251101"),
            Self::ClaudeOpus45 => write!(f, "claude-opus-4-5"),
            Self::Claude37SonnetLatest => write!(f, "claude-3-7-sonnet-latest"),
            Self::Claude37Sonnet20250219 => write!(f, "claude-3-7-sonnet-20250219"),
            Self::Claude35HaikuLatest => write!(f, "claude-3-5-haiku-latest"),
            Self::Claude35Haiku20241022 => write!(f, "claude-3-5-haiku-20241022"),
            Self::ClaudeHaiku45 => write!(f, "claude-haiku-4-5"),
            Self::ClaudeHaiku4520251001 => write!(f, "claude-haiku-4-5-20251001"),
            Self::ClaudeSonnet420250514 => write!(f, "claude-sonnet-4-20250514"),
            Self::ClaudeSonnet40 => write!(f, "claude-sonnet-4-0"),
            Self::Claude4Sonnet20250514 => write!(f, "claude-4-sonnet-20250514"),
            Self::ClaudeSonnet45 => write!(f, "claude-sonnet-4-5"),
            Self::ClaudeSonnet4520250929 => write!(f, "claude-sonnet-4-5-20250929"),
            Self::ClaudeOpus40 => write!(f, "claude-opus-4-0"),
            Self::ClaudeOpus420250514 => write!(f, "claude-opus-4-20250514"),
            Self::Claude4Opus20250514 => write!(f, "claude-4-opus-20250514"),
            Self::ClaudeOpus4120250805 => write!(f, "claude-opus-4-1-20250805"),
            Self::Claude3OpusLatest => write!(f, "claude-3-opus-latest"),
            Self::Claude3Opus20240229 => write!(f, "claude-3-opus-20240229"),
            Self::Claude3Haiku20240307 => write!(f, "claude-3-haiku-20240307"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct NotFoundError {
    #[validate(length(min = 1u64))]
    #[default(Some("Not found".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("not_found_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct OverloadedError {
    #[validate(length(min = 1u64))]
    #[default(Some("Overloaded".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("overloaded_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct PermissionError {
    #[validate(length(min = 1u64))]
    #[default(Some("Permission denied".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("permission_error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct PlainTextSource {
    #[validate(length(min = 1u64))]
    pub data: String,
    #[validate(length(min = 1u64))]
    #[default("text/plain".to_string())]
    pub media_type: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct RateLimitError {
    #[validate(length(min = 1u64))]
    #[default(Some("Rate limited".to_string()))]
    pub message: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("rate_limit_error".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum RequestBlockKind {
    Image(RequestImageBlock),
    Text(RequestTextBlock),
}
impl RequestBlockKind {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for RequestBlockKind {
    fn default() -> Self {
        Self::Image(<RequestImageBlock>::default())
    }
}
impl serde::Serialize for RequestBlockKind {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Image(v) => v.serialize(serializer),
            Self::Text(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for RequestBlockKind {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("image") => serde_json::from_value(value)
                .map(Self::Image)
                .map_err(serde::de::Error::custom),
            Some("text") => serde_json::from_value(value)
                .map(Self::Text)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl RequestBlockKind {
    pub fn text(text: String) -> Self {
        Self::Text(RequestTextBlock {
            text,
            ..Default::default()
        })
    }
    pub fn image(source: RequestImageBlockSource) -> Self {
        Self::Image(RequestImageBlock {
            source,
            ..Default::default()
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum RequestBlockKind2 {
    Document(RequestDocumentBlock),
    Image(RequestImageBlock),
    SearchResult(RequestSearchResultBlock),
    Text(RequestTextBlock),
}
impl RequestBlockKind2 {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for RequestBlockKind2 {
    fn default() -> Self {
        Self::Document(<RequestDocumentBlock>::default())
    }
}
impl serde::Serialize for RequestBlockKind2 {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Document(v) => v.serialize(serializer),
            Self::Image(v) => v.serialize(serializer),
            Self::SearchResult(v) => v.serialize(serializer),
            Self::Text(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for RequestBlockKind2 {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("document") => serde_json::from_value(value)
                .map(Self::Document)
                .map_err(serde::de::Error::custom),
            Some("image") => serde_json::from_value(value)
                .map(Self::Image)
                .map_err(serde::de::Error::custom),
            Some("search_result") => serde_json::from_value(value)
                .map(Self::SearchResult)
                .map_err(serde::de::Error::custom),
            Some("text") => serde_json::from_value(value)
                .map(Self::Text)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl RequestBlockKind2 {
    pub fn text(text: String) -> Self {
        Self::Text(RequestTextBlock {
            text,
            ..Default::default()
        })
    }
    pub fn image(source: RequestImageBlockSource) -> Self {
        Self::Image(RequestImageBlock {
            source,
            ..Default::default()
        })
    }
    pub fn document(source: RequestDocumentBlockSource) -> Self {
        Self::Document(RequestDocumentBlock {
            source,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestCharLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_char_index: i64,
    #[validate(range(min = 0i64))]
    pub start_char_index: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("char_location".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields)]
pub struct RequestCitationsConfig {
    pub enabled: Option<bool>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestContentBlockLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_block_index: i64,
    #[validate(range(min = 0i64))]
    pub start_block_index: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("content_block_location".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct RequestCounts {
    ///Number of requests in the Message Batch that have been canceled.
    ///
    ///This is zero until processing of the entire Message Batch has ended.
    #[default(Some(0i64))]
    pub canceled: Option<i64>,
    ///Number of requests in the Message Batch that encountered an error.
    ///
    ///This is zero until processing of the entire Message Batch has ended.
    #[default(Some(0i64))]
    pub errored: Option<i64>,
    ///Number of requests in the Message Batch that have expired.
    ///
    ///This is zero until processing of the entire Message Batch has ended.
    #[default(Some(0i64))]
    pub expired: Option<i64>,
    ///Number of requests in the Message Batch that are processing.
    #[default(Some(0i64))]
    pub processing: Option<i64>,
    ///Number of requests in the Message Batch that have completed successfully.
    ///
    ///This is zero until processing of the entire Message Batch has ended.
    #[default(Some(0i64))]
    pub succeeded: Option<i64>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestDocumentBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    pub citations: Option<RequestCitationsConfig>,
    pub context: Option<String>,
    pub source: RequestDocumentBlockSource,
    pub title: Option<String>,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("document".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum RequestDocumentBlockSource {
    Base64PDF(Base64PDFSource),
    ContentBlock(ContentBlockSource),
    PlainText(PlainTextSource),
    URLPDF(URLPDFSource),
}
impl RequestDocumentBlockSource {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for RequestDocumentBlockSource {
    fn default() -> Self {
        Self::Base64PDF(<Base64PDFSource>::default())
    }
}
impl serde::Serialize for RequestDocumentBlockSource {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Base64PDF(v) => v.serialize(serializer),
            Self::ContentBlock(v) => v.serialize(serializer),
            Self::PlainText(v) => v.serialize(serializer),
            Self::URLPDF(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for RequestDocumentBlockSource {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("base64") => serde_json::from_value(value)
                .map(Self::Base64PDF)
                .map_err(serde::de::Error::custom),
            Some("content") => serde_json::from_value(value)
                .map(Self::ContentBlock)
                .map_err(serde::de::Error::custom),
            Some("text") => serde_json::from_value(value)
                .map(Self::PlainText)
                .map_err(serde::de::Error::custom),
            Some("url") => serde_json::from_value(value)
                .map(Self::URLPDF)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl RequestDocumentBlockSource {
    pub fn base64pdf(data: Vec<u8>) -> Self {
        Self::Base64PDF(Base64PDFSource {
            data,
            ..Default::default()
        })
    }
    pub fn plain_text(data: String) -> Self {
        Self::PlainText(PlainTextSource {
            data,
            ..Default::default()
        })
    }
    pub fn content(content: ContentBlockSourceContent) -> Self {
        Self::ContentBlock(ContentBlockSource {
            content,
            ..Default::default()
        })
    }
    pub fn urlpdf(url: String) -> Self {
        Self::URLPDF(URLPDFSource {
            url,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestImageBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    pub source: RequestImageBlockSource,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("image".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq)]
pub enum RequestImageBlockSource {
    Base64(Base64ImageSource),
    URL(URLImageSource),
}
impl RequestImageBlockSource {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for RequestImageBlockSource {
    fn default() -> Self {
        Self::Base64(<Base64ImageSource>::default())
    }
}
impl serde::Serialize for RequestImageBlockSource {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Base64(v) => v.serialize(serializer),
            Self::URL(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for RequestImageBlockSource {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("base64") => serde_json::from_value(value)
                .map(Self::Base64)
                .map_err(serde::de::Error::custom),
            Some("url") => serde_json::from_value(value)
                .map(Self::URL)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl RequestImageBlockSource {
    pub fn url(url: String) -> Self {
        Self::URL(URLImageSource {
            url,
            ..Default::default()
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum RequestLocationCitationKind {
    Char(RequestCharLocationCitation),
    ContentBlock(RequestContentBlockLocationCitation),
    Page(RequestPageLocationCitation),
    SearchResult(RequestSearchResultLocationCitation),
    WebSearchResult(RequestWebSearchResultLocationCitation),
}
impl RequestLocationCitationKind {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for RequestLocationCitationKind {
    fn default() -> Self {
        Self::Char(<RequestCharLocationCitation>::default())
    }
}
impl serde::Serialize for RequestLocationCitationKind {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Char(v) => v.serialize(serializer),
            Self::ContentBlock(v) => v.serialize(serializer),
            Self::Page(v) => v.serialize(serializer),
            Self::SearchResult(v) => v.serialize(serializer),
            Self::WebSearchResult(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for RequestLocationCitationKind {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("char_location") => serde_json::from_value(value)
                .map(Self::Char)
                .map_err(serde::de::Error::custom),
            Some("content_block_location") => serde_json::from_value(value)
                .map(Self::ContentBlock)
                .map_err(serde::de::Error::custom),
            Some("page_location") => serde_json::from_value(value)
                .map(Self::Page)
                .map_err(serde::de::Error::custom),
            Some("search_result_location") => serde_json::from_value(value)
                .map(Self::SearchResult)
                .map_err(serde::de::Error::custom),
            Some("web_search_result_location") => serde_json::from_value(value)
                .map(Self::WebSearchResult)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestPageLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_page_number: i64,
    #[validate(range(min = 1i64))]
    pub start_page_number: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("page_location".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestRedactedThinkingBlock {
    #[validate(length(min = 1u64))]
    pub data: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("redacted_thinking".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestSearchResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    pub citations: Option<RequestCitationsConfig>,
    #[validate(nested)]
    pub content: Vec<RequestTextBlock>,
    #[validate(length(min = 1u64))]
    pub source: String,
    #[validate(length(min = 1u64))]
    pub title: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("search_result".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestSearchResultLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    pub end_block_index: i64,
    #[validate(range(min = 0i64))]
    pub search_result_index: i64,
    #[validate(length(min = 1u64))]
    pub source: String,
    #[validate(range(min = 0i64))]
    pub start_block_index: i64,
    pub title: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("search_result_location".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestServerToolUseBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub id: String,
    pub input: std::collections::HashMap<String, serde_json::Value>,
    #[validate(length(min = 1u64))]
    #[default("web_search".to_string())]
    pub name: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("server_tool_use".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestTextBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    pub citations: Option<RequestTextBlockCitations>,
    #[validate(length(min = 1u64))]
    pub text: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("text".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum RequestTextBlockCitations {
    #[default]
    Array(Vec<RequestLocationCitationKind>),
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestThinkingBlock {
    #[validate(length(min = 1u64))]
    pub signature: String,
    #[validate(length(min = 1u64))]
    pub thinking: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("thinking".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestToolResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    pub content: Option<RequestToolResultBlockContent>,
    pub is_error: Option<bool>,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_MCPTOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum RequestToolResultBlockContent {
    #[default]
    String(String),
    Array(Vec<RequestBlockKind2>),
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestToolUseBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_MCPTOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub id: String,
    pub input: std::collections::HashMap<String, serde_json::Value>,
    #[validate(length(min = 1u64, max = 200u64))]
    pub name: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("tool_use".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestWebSearchResultBlock {
    #[validate(length(min = 1u64))]
    pub encrypted_content: String,
    pub page_age: Option<String>,
    #[validate(length(min = 1u64))]
    pub title: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("web_search_result".to_string())]
    pub r#type: String,
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestWebSearchResultLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(length(min = 1u64))]
    pub encrypted_index: String,
    pub title: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("web_search_result_location".to_string())]
    pub r#type: String,
    #[validate(length(min = 1u64, max = 2_048u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestWebSearchToolResultBlock {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    pub content: RequestWebSearchToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("web_search_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum RequestWebSearchToolResultBlockContent {
    #[default]
    WebSearchToolResultBlockItem(Vec<RequestWebSearchResultBlock>),
    RequestWebSearchToolResultError(RequestWebSearchToolResultError),
}
impl RequestWebSearchToolResultBlockContent {
    pub fn error(error_code: WebSearchToolResultErrorCode) -> Self {
        Self::RequestWebSearchToolResultError(RequestWebSearchToolResultError {
            error_code,
            ..Default::default()
        })
    }
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct RequestWebSearchToolResultError {
    pub error_code: WebSearchToolResultErrorCode,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("web_search_tool_result_error".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseCharLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_char_index: i64,
    pub file_id: Option<String>,
    #[validate(range(min = 0i64))]
    pub start_char_index: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("char_location".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseContentBlockLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_block_index: i64,
    pub file_id: Option<String>,
    #[validate(range(min = 0i64))]
    pub start_block_index: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("content_block_location".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponsePageLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(range(min = 0i64))]
    pub document_index: i64,
    pub document_title: Option<String>,
    pub end_page_number: i64,
    pub file_id: Option<String>,
    #[validate(range(min = 1i64))]
    pub start_page_number: i64,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("page_location".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseRedactedThinkingBlock {
    #[validate(length(min = 1u64))]
    pub data: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("redacted_thinking".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseSearchResultLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    pub end_block_index: i64,
    #[validate(range(min = 0i64))]
    pub search_result_index: i64,
    #[validate(length(min = 1u64))]
    pub source: String,
    #[validate(range(min = 0i64))]
    pub start_block_index: i64,
    pub title: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("search_result_location".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseServerToolUseBlock {
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub id: String,
    pub input: std::collections::HashMap<String, serde_json::Value>,
    #[validate(length(min = 1u64))]
    #[default("web_search".to_string())]
    pub name: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("server_tool_use".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseTextBlock {
    ///Citations supporting the text block.
    ///
    ///The type of citation returned will depend on the type of document being cited. Citing a PDF results in `page_location`, plain text results in `char_location`, and content document results in `content_block_location`.
    pub citations: ResponseTextBlockCitations,
    #[validate(length(min = 0u64, max = 5_000_000u64))]
    pub text: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("text".to_string()))]
    pub r#type: Option<String>,
}
///Citations supporting the text block.
///
///The type of citation returned will depend on the type of document being cited. Citing a PDF results in `page_location`, plain text results in `char_location`, and content document results in `content_block_location`.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum ResponseTextBlockCitations {
    #[default]
    Array(Vec<CitationsDeltaCitation>),
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseThinkingBlock {
    #[validate(length(min = 1u64))]
    pub signature: String,
    #[validate(length(min = 1u64))]
    pub thinking: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("thinking".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseToolUseBlock {
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_MCPTOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub id: String,
    pub input: std::collections::HashMap<String, serde_json::Value>,
    #[validate(length(min = 1u64))]
    pub name: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("tool_use".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseWebSearchResultBlock {
    #[validate(length(min = 1u64))]
    pub encrypted_content: String,
    pub page_age: Option<String>,
    #[validate(length(min = 1u64))]
    pub title: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("web_search_result".to_string()))]
    pub r#type: Option<String>,
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseWebSearchResultLocationCitation {
    #[validate(length(min = 1u64))]
    pub cited_text: String,
    #[validate(length(min = 1u64))]
    pub encrypted_index: String,
    pub title: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("web_search_result_location".to_string()))]
    pub r#type: Option<String>,
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseWebSearchToolResultBlock {
    pub content: ResponseWebSearchToolResultBlockContent,
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_BETA_REQUEST_BASH_CODE_EXECUTION_TOOL_RESULT_BLOCK_TOOL_USE_ID")
    )]
    pub tool_use_id: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("web_search_tool_result".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum ResponseWebSearchToolResultBlockContent {
    #[default]
    ResponseWebSearchToolResultError(ResponseWebSearchToolResultError),
    Array(Vec<ResponseWebSearchResultBlock>),
}
impl ResponseWebSearchToolResultBlockContent {
    pub fn error(error_code: WebSearchToolResultErrorCode) -> Self {
        Self::ResponseWebSearchToolResultError(ResponseWebSearchToolResultError {
            error_code,
            ..Default::default()
        })
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ResponseWebSearchToolResultError {
    pub error_code: WebSearchToolResultErrorCode,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("web_search_tool_result_error".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ServerToolUsage {
    ///The number of web search tool requests.
    #[validate(range(min = 0i64))]
    #[default(Some(0i64))]
    pub web_search_requests: Option<i64>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum ServerToolUseBlockName {
    #[serde(rename = "web_search")]
    #[default]
    WebSearch,
    #[serde(rename = "web_fetch")]
    WebFetch,
    #[serde(rename = "code_execution")]
    CodeExecution,
    #[serde(rename = "bash_code_execution")]
    BashCodeExecution,
    #[serde(rename = "text_editor_code_execution")]
    TextEditorCodeExecution,
    #[serde(rename = "tool_search_tool_regex")]
    ToolSearchToolRegex,
    #[serde(rename = "tool_search_tool_bm25")]
    ToolSearchToolBm25,
}
impl core::fmt::Display for ServerToolUseBlockName {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::WebSearch => write!(f, "web_search"),
            Self::WebFetch => write!(f, "web_fetch"),
            Self::CodeExecution => write!(f, "code_execution"),
            Self::BashCodeExecution => write!(f, "bash_code_execution"),
            Self::TextEditorCodeExecution => write!(f, "text_editor_code_execution"),
            Self::ToolSearchToolRegex => write!(f, "tool_search_tool_regex"),
            Self::ToolSearchToolBm25 => write!(f, "tool_search_tool_bm25"),
        }
    }
}
///Determines whether to use priority capacity (if available) or standard capacity for this request.
///
///Anthropic offers different levels of service for your API requests. See [service-tiers](https://docs.claude.com/en/api/service-tiers) for details.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum ServiceTier {
    #[serde(rename = "auto")]
    #[default]
    Auto,
    #[serde(rename = "standard_only")]
    StandardOnly,
}
impl core::fmt::Display for ServiceTier {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Auto => write!(f, "auto"),
            Self::StandardOnly => write!(f, "standard_only"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct SignatureContentBlockDelta {
    #[validate(length(min = 1u64))]
    pub signature: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("signature_delta".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct Skill {
    ///ISO 8601 timestamp of when the skill was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Display title for the skill.
    ///
    ///This is a human-readable label that is not included in the prompt sent to the model.
    pub display_title: Option<String>,
    ///Unique identifier for the skill.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///The latest version identifier for the skill.
    ///
    ///This represents the most recent version of the skill that has been created.
    pub latest_version: Option<String>,
    ///Source of the skill.
    ///
    ///This may be one of the following values:
    ///* `"custom"`: the skill was created by a user
    ///* `"anthropic"`: the skill was created by Anthropic
    #[validate(length(min = 1u64))]
    pub source: String,
    ///Object type.
    ///
    ///For Skills, this is always `"skill"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill".to_string()))]
    pub r#type: Option<String>,
    ///ISO 8601 timestamp of when the skill was last updated.
    #[validate(length(min = 1u64))]
    pub updated_at: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct SkillVersion {
    ///ISO 8601 timestamp of when the skill version was created.
    #[validate(length(min = 1u64))]
    pub created_at: String,
    ///Description of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub description: String,
    ///Directory name of the skill version.
    ///
    ///This is the top-level directory name that was extracted from the uploaded files.
    #[validate(length(min = 1u64))]
    pub directory: String,
    ///Unique identifier for the skill version.
    ///
    ///The format and length of IDs may change over time.
    #[validate(length(min = 1u64))]
    pub id: String,
    ///Human-readable name of the skill version.
    ///
    ///This is extracted from the SKILL.md file in the skill upload.
    #[validate(length(min = 1u64))]
    pub name: String,
    ///Identifier for the skill that this version belongs to.
    #[validate(length(min = 1u64))]
    pub skill_id: String,
    ///Object type.
    ///
    ///For Skill Versions, this is always `"skill_version"`.
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("skill_version".to_string()))]
    pub r#type: Option<String>,
    ///Version identifier for the skill.
    ///
    ///Each version is identified by a Unix epoch timestamp (e.g., "1759178010641129").
    #[validate(length(min = 1u64))]
    pub version: String,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum StopReason {
    #[serde(rename = "end_turn")]
    #[default]
    EndTurn,
    #[serde(rename = "max_tokens")]
    MaxTokens,
    #[serde(rename = "stop_sequence")]
    StopSequence,
    #[serde(rename = "tool_use")]
    ToolUse,
    #[serde(rename = "pause_turn")]
    PauseTurn,
    #[serde(rename = "refusal")]
    Refusal,
}
impl core::fmt::Display for StopReason {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::EndTurn => write!(f, "end_turn"),
            Self::MaxTokens => write!(f, "max_tokens"),
            Self::StopSequence => write!(f, "stop_sequence"),
            Self::ToolUse => write!(f, "tool_use"),
            Self::PauseTurn => write!(f, "pause_turn"),
            Self::Refusal => write!(f, "refusal"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct SucceededResult {
    #[validate(nested)]
    pub message: Message,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("succeeded".to_string()))]
    pub r#type: Option<String>,
}
///System prompt.
///
///A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our [guide to system prompts](https://docs.claude.com/en/docs/system-prompts).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum System {
    #[default]
    String(String),
    Array(Vec<RequestTextBlock>),
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct TextContentBlockDelta {
    #[validate(length(min = 1u64))]
    pub text: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("text_delta".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct TextEditor20250124 {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("str_replace_editor".to_string())]
    pub name: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text_editor_20250124".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct TextEditor20250429 {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("str_replace_based_edit_tool".to_string())]
    pub name: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text_editor_20250429".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct TextEditor20250728 {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    ///Maximum number of characters to display when viewing a file. If not specified, defaults to displaying the full file.
    pub max_characters: Option<i64>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("str_replace_based_edit_tool".to_string())]
    pub name: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("text_editor_20250728".to_string())]
    pub r#type: String,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum TextEditorCodeExecutionViewResultBlockFileType {
    #[serde(rename = "text")]
    #[default]
    Text,
    #[serde(rename = "image")]
    Image,
    #[serde(rename = "pdf")]
    Pdf,
}
impl core::fmt::Display for TextEditorCodeExecutionViewResultBlockFileType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Text => write!(f, "text"),
            Self::Image => write!(f, "image"),
            Self::Pdf => write!(f, "pdf"),
        }
    }
}
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields, default)]
pub struct ThinkingConfigDisabled {
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("disabled".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct ThinkingConfigEnabled {
    ///Determines how many tokens Claude can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality.
    ///
    ///Must be 1024 and less than `max_tokens`.
    ///
    ///See [extended thinking](https://docs.claude.com/en/docs/build-with-claude/extended-thinking) for details.
    #[validate(range(min = 1_024i64))]
    pub budget_tokens: i64,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("enabled".to_string()))]
    pub r#type: Option<String>,
}
///Configuration for enabling Claude's extended thinking.
///
///When enabled, responses include `thinking` content blocks showing Claude's thinking process before the final answer. Requires a minimum budget of 1,024 tokens and counts towards your `max_tokens` limit.
///
///See [extended thinking](https://docs.claude.com/en/docs/build-with-claude/extended-thinking) for details.
#[derive(Debug, Clone, PartialEq)]
pub enum ThinkingConfigParam {
    Disabled(ThinkingConfigDisabled),
    Enabled(ThinkingConfigEnabled),
}
impl ThinkingConfigParam {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for ThinkingConfigParam {
    fn default() -> Self {
        Self::Disabled(<ThinkingConfigDisabled>::default())
    }
}
impl serde::Serialize for ThinkingConfigParam {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Disabled(v) => v.serialize(serializer),
            Self::Enabled(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for ThinkingConfigParam {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("disabled") => serde_json::from_value(value)
                .map(Self::Disabled)
                .map_err(serde::de::Error::custom),
            Some("enabled") => serde_json::from_value(value)
                .map(Self::Enabled)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl ThinkingConfigParam {
    pub fn enabled(budget_tokens: i64) -> Self {
        Self::Enabled(ThinkingConfigEnabled {
            budget_tokens,
            ..Default::default()
        })
    }
    pub fn disabled() -> Self {
        Self::Disabled(ThinkingConfigDisabled::default())
    }
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(default)]
pub struct ThinkingContentBlockDelta {
    #[validate(length(min = 1u64))]
    pub thinking: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default(Some("thinking_delta".to_string()))]
    pub r#type: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields)]
pub struct Tool {
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    ///Description of what this tool does.
    ///
    ///Tool descriptions should be as detailed as possible. The more information that the model has about what the tool is and how to use it, the better it will perform. You can use natural language descriptions to reinforce important aspects of the tool input JSON schema.
    pub description: Option<String>,
    #[validate(nested)]
    pub input_schema: InputSchema,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64, max = 128u64), regex(path = "REGEX_BETA_TOOL_NAME"))]
    pub name: String,
    #[serde(rename = "type")]
    pub r#type: Option<String>,
}
///How the model should use the provided tools. The model can use a specific tool, any available tool, decide by itself, or not use tools at all.
#[derive(Debug, Clone, PartialEq)]
pub enum ToolChoice {
    Any(ToolChoiceAny),
    Auto(ToolChoiceAuto),
    None(ToolChoiceNone),
    Tool(ToolChoiceTool),
}
impl ToolChoice {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for ToolChoice {
    fn default() -> Self {
        Self::Any(<ToolChoiceAny>::default())
    }
}
impl serde::Serialize for ToolChoice {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Any(v) => v.serialize(serializer),
            Self::Auto(v) => v.serialize(serializer),
            Self::None(v) => v.serialize(serializer),
            Self::Tool(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for ToolChoice {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("any") => serde_json::from_value(value)
                .map(Self::Any)
                .map_err(serde::de::Error::custom),
            Some("auto") => serde_json::from_value(value)
                .map(Self::Auto)
                .map_err(serde::de::Error::custom),
            Some("none") => serde_json::from_value(value)
                .map(Self::None)
                .map_err(serde::de::Error::custom),
            Some("tool") => serde_json::from_value(value)
                .map(Self::Tool)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl ToolChoice {
    ///The model will automatically decide whether to use tools.
    pub fn auto(disable_parallel_tool_use: Option<bool>) -> Self {
        Self::Auto(ToolChoiceAuto {
            disable_parallel_tool_use,
            ..Default::default()
        })
    }
    ///The model will use any available tools.
    pub fn any(disable_parallel_tool_use: Option<bool>) -> Self {
        Self::Any(ToolChoiceAny {
            disable_parallel_tool_use,
            ..Default::default()
        })
    }
    ///The model will use the specified tool with `tool_choice.name`.
    pub fn tool(name: String) -> Self {
        Self::Tool(ToolChoiceTool {
            name,
            ..Default::default()
        })
    }
    ///The model will not be allowed to use tools.
    pub fn none() -> Self {
        Self::None(ToolChoiceNone::default())
    }
}
///The model will use any available tools.
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields, default)]
pub struct ToolChoiceAny {
    ///Whether to disable parallel tool use.
    ///
    ///Defaults to `false`. If set to `true`, the model will output exactly one tool use.
    pub disable_parallel_tool_use: Option<bool>,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("any".to_string()))]
    pub r#type: Option<String>,
}
///The model will automatically decide whether to use tools.
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields, default)]
pub struct ToolChoiceAuto {
    ///Whether to disable parallel tool use.
    ///
    ///Defaults to `false`. If set to `true`, the model will output at most one tool use.
    pub disable_parallel_tool_use: Option<bool>,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("auto".to_string()))]
    pub r#type: Option<String>,
}
///The model will not be allowed to use tools.
#[serde_with::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(deny_unknown_fields, default)]
pub struct ToolChoiceNone {
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("none".to_string()))]
    pub r#type: Option<String>,
}
///The model will use the specified tool with `tool_choice.name`.
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct ToolChoiceTool {
    ///Whether to disable parallel tool use.
    ///
    ///Defaults to `false`. If set to `true`, the model will output exactly one tool use.
    pub disable_parallel_tool_use: Option<bool>,
    ///The name of the tool to use.
    #[validate(length(min = 1u64))]
    pub name: String,
    #[doc(hidden)]
    #[serde(default, rename = "type", skip_deserializing)]
    #[default(Some("tool".to_string()))]
    pub r#type: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum ToolKind {
    #[default]
    Tool(Tool),
    BashTool20250124(BashTool20250124),
    TextEditor20250124(TextEditor20250124),
    TextEditor20250429(TextEditor20250429),
    TextEditor20250728(TextEditor20250728),
    WebSearchTool20250305(WebSearchTool20250305),
}
impl ToolKind {
    pub fn bash_tool20250124() -> Self {
        Self::BashTool20250124(BashTool20250124::default())
    }
}
#[derive(Debug, Clone, PartialEq)]
pub enum ToolUseBlockCaller {
    Direct(BetaDirectCaller),
    ServerTool(BetaServerToolCaller),
}
impl ToolUseBlockCaller {
    pub const DISCRIMINATOR_FIELD: &'static str = "type";
}
impl Default for ToolUseBlockCaller {
    fn default() -> Self {
        Self::Direct(<BetaDirectCaller>::default())
    }
}
impl serde::Serialize for ToolUseBlockCaller {
    fn serialize<S>(&self, serializer: S) -> core::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Direct(v) => v.serialize(serializer),
            Self::ServerTool(v) => v.serialize(serializer),
        }
    }
}
impl<'de> serde::Deserialize<'de> for ToolUseBlockCaller {
    fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;
        match value
            .get(Self::DISCRIMINATOR_FIELD)
            .and_then(|v| v.as_str())
        {
            Some("direct") => serde_json::from_value(value)
                .map(Self::Direct)
                .map_err(serde::de::Error::custom),
            Some("code_execution_20250825") => serde_json::from_value(value)
                .map(Self::ServerTool)
                .map_err(serde::de::Error::custom),
            None => Err(serde::de::Error::missing_field(Self::DISCRIMINATOR_FIELD)),
            Some(other) => Err(serde::de::Error::custom(format!(
                "Unknown discriminator value '{}' for field '{}'",
                other, "type"
            ))),
        }
    }
}
impl ToolUseBlockCaller {
    ///Tool invocation directly from the model.
    pub fn direct(r#type: String) -> Self {
        Self::Direct(BetaDirectCaller {
            r#type,
            ..Default::default()
        })
    }
    ///Tool invocation generated by a server-side tool.
    pub fn server(tool_id: String) -> Self {
        Self::ServerTool(BetaServerToolCaller {
            tool_id,
            ..Default::default()
        })
    }
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct URLImageSource {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("url".to_string())]
    pub r#type: String,
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct URLPDFSource {
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("url".to_string())]
    pub r#type: String,
    #[validate(length(min = 1u64))]
    pub url: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
pub struct Usage {
    ///Breakdown of cached tokens by TTL
    #[validate(nested)]
    pub cache_creation: Option<CacheCreation>,
    ///The number of input tokens used to create the cache entry.
    pub cache_creation_input_tokens: Option<i64>,
    ///The number of input tokens read from the cache.
    pub cache_read_input_tokens: Option<i64>,
    ///The number of input tokens which were used.
    #[validate(range(min = 0i64))]
    pub input_tokens: i64,
    ///The number of output tokens which were used.
    #[validate(range(min = 0i64))]
    pub output_tokens: i64,
    ///The number of server tool requests.
    #[validate(nested)]
    pub server_tool_use: Option<ServerToolUsage>,
    ///If the request used the priority, standard, or batch tier.
    pub service_tier: Option<String>,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct UserLocation {
    ///The city of the user.
    pub city: Option<String>,
    ///The two letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the user.
    pub country: Option<String>,
    ///The region of the user.
    pub region: Option<String>,
    ///The [IANA timezone](https://nodatime.org/TimeZones) of the user.
    pub timezone: Option<String>,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("approximate".to_string())]
    pub r#type: String,
}
#[serde_with::skip_serializing_none]
#[derive(
    Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default,
)]
#[serde(deny_unknown_fields, default)]
pub struct WebSearchTool20250305 {
    ///If provided, only these domains will be included in results. Cannot be used alongside `blocked_domains`.
    pub allowed_domains: Option<Vec<String>>,
    ///If provided, these domains will never appear in results. Cannot be used alongside `allowed_domains`.
    pub blocked_domains: Option<Vec<String>>,
    ///Create a cache control breakpoint at this content block.
    #[validate(nested)]
    pub cache_control: Option<CacheControlEphemeral>,
    ///Maximum number of times the tool can be used in the API request.
    pub max_uses: Option<i64>,
    ///Name of the tool.
    ///
    ///This is how the tool will be called by the model and in `tool_use` blocks.
    #[validate(length(min = 1u64))]
    #[default("web_search".to_string())]
    pub name: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1u64))]
    #[default("web_search_20250305".to_string())]
    pub r#type: String,
    ///Parameters for the user's location. Used to provide more relevant search results.
    #[validate(nested)]
    pub user_location: Option<UserLocation>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum WebSearchToolResultErrorCode {
    #[serde(rename = "invalid_tool_input")]
    #[default]
    InvalidToolInput,
    #[serde(rename = "unavailable")]
    Unavailable,
    #[serde(rename = "max_uses_exceeded")]
    MaxUsesExceeded,
    #[serde(rename = "too_many_requests")]
    TooManyRequests,
    #[serde(rename = "query_too_long")]
    QueryTooLong,
}
impl core::fmt::Display for WebSearchToolResultErrorCode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::InvalidToolInput => write!(f, "invalid_tool_input"),
            Self::Unavailable => write!(f, "unavailable"),
            Self::MaxUsesExceeded => write!(f, "max_uses_exceeded"),
            Self::TooManyRequests => write!(f, "too_many_requests"),
            Self::QueryTooLong => write!(f, "query_too_long"),
        }
    }
}
